System standingbuffetservice
//TODO 3 Caricare lo stato (PROLOG) 
//FIXME gestire i messaggi a seconda del mittente
//FIXME observer getCoapState se non riesci a sfruttare la chiamata a metodo puoi prendere spunto da /home/gnuff/issLab2021/it.unibo.qakDemo/test/it/unibo/qakDemo/CoapObserverForTesting.kt
// e da /home/gnuff/issLab2021/it.unibo.qak21.basicrobot/test/it/unibo/qak21/basicrobot/TestPlan1.kt
//TODO studia bene cosa fa l'observer se gli viene passato l'attore
Event observerfridge:observerfridge(X)
Event observerpantry:observerpantry(X)
Event observertable:observertable(X)
Event observerdishwasher:observerdishwasher(X)
//Event observer:observer(X)

//Maitre-RBR
Dispatch prepare:prepare(X,Y)//void
Request addFood:addFood(FOODE_CODE)
Dispatch clear:clear(ARG)//void
//O sono eventi ??
Dispatch stop:stop(ARG)//void
Dispatch reactivate:reactivate(ARG)//void

Reply warning:warning(ARG)//void

//Ho rimosso exopose gestito come dispatcher
//Maitre-Fridge
Dispatch consult:consult(ARG)//void

//RBR-Fridge
//Dispatch askFood:askFood(FOODE_CODE) 
//Dispatch answer:answer(ARG)	// ARG= true/false
Dispatch askFood:askFood(FOODE_CODE) 
Dispatch answer:answer(ARG)	// ARG= true/false
//RBR-Res
//Dispatch changeState:changeState(X)
Dispatch add:add(X)
Dispatch remove:remove(X)
Dispatch addDishes:addDishes(X)
Dispatch removeDishes:removeDishes(X)
Dispatch addFood:addFood(X)
Dispatch removeFood:removeFood(X)

//Context ctxsystem ip [host="localhost" port=8040]
//Context ctxmaitre ip [host="192.168.1.211" port=8070]
Context ctxrbr ip [host="127.0.0.1" port=8050]
//Context ctxfridge ip [host="127.0.0.1" port=8060]  
//Context ctxres ip [host="192.168.1.211" port=8070]
//Context ctxmaitre ip [host="localhost" port=8070]
//Context ctxrbr ip [host="localhost" port=8050]
Context ctxfridge ip [host="localhost" port=8060]  
Context ctxres ip [host="localhost"  port=8080]


QActor rbr context ctxrbr{
	[# 	var FoodPresence = false 
		var PrepareDish = 0
		var PrepareFood = emptyArray<Int>()
		var ClearDish = 0
		var ClearFood = emptyArray<Int>()
		var IsMap = false
	#]	
		
//TODO nell'analisi dei requisiti qua attendiamo direttametne prepare è opportuno inserire lo stato e planning work già prima ?
	State s0 initial {
		println ("RBR | STARTS and it's placed in RH position")

		[#
			IsMap = true  	
			//util.ActorCoapObserver("localhost",8040,"ctxsystem","fridge").activate(myself)
		#]
		
	}
	Goto working if [# IsMap #] else mapping
	
	State mapping {
		println ("RBR | initializing planner")
		println ("RBR | start mapping room ")
		delay 300 
		println ("RBR | end mapping step")
		[# IsMap = true#]
	
	}Goto working
 
	State working {
		println ("RBR | STARTS and it's ready to work")
	}
	Transition t0
		whenMsg prepare -> exPrepare
	
	State exPrepare {
		onMsg( prepare:prepare(X,Y) ) {
	 		[# 	PrepareDish = payloadArg(0).toInt()
				PrepareFood = payloadArg(1).map{ it.toInt() }.toTypedArray()
			#]
 		}
 		
		println ("RBR | executing task 'Prepare the room'; DISHES= $PrepareDish; Foods= $PrepareFood:" )
		println ("RBR | going to pantry...")
		
		forward pantry -m remove : remove($PrepareDish)
		
		println ("RBR | ...reached pantry. Going to table...")
		forward table -m addDishes : addDishes($PrepareDish)
		
		println ("RBR | ...reached table. Going to fridge...")
		forward fridge -m remove : remove($PrepareFood)
		
		println ("RBR | ...reached fridge. Going to table...")
		forward table -m addFood : addFood($PrepareFood)
		
		println ("RBR | ...reached table. Coming back to RH...")
		println ("RBR | ...reached RH. Finished executing task") 
	}
	Goto wait
	
	State wait {
		println ("RBR | is placed in RH position and it's waiting for a command...")
	}
	Transition t1
		whenMsg addFood -> checkFood
		whenMsg clear -> exClear
		
	State checkFood {
		[# var Food_Code = -1 #]
		onMsg( addFood:addFood(ARG) ) {
	 		[# Food_Code = payloadArg(0).toInt() #]
 		}

 		forward fridge -m askFood : askFood($Food_Code)
 		println ("RBR | asked fridge if it contains the food with food-code = $Food_Code")
	}
	Transition t2
		whenEvent observerfridge -> handleReply
			
	State handleReply {
		onMsg( observerfridge:observerfridge(X) ) {
	 		[# FoodPresence = payloadArg(0).toBoolean() #]
 		}
		println ("RBR | received answer from fridge: $FoodPresence")
	}
	Goto fail if [# FoodPresence == false #] else exAddFood

	State fail {
		replyTo addFood with warning:warning(w)
		println ("RBR | send warning to maitre")
	}
	Goto wait

	State exAddFood {
		println ("RBR | executing task 'Add food'")
		println ("RBR | going to fridge...")
		println ("RBR | ...reached fridge. Going to table...")
		println ("RBR | ...reached table. Coming back to RH...")
		println ("RBR | ...reached RH. Finished executing task")
	}
	Goto wait
	
	State exClear {
//TODO clear deve prima mandare un consult al tavolo per conoscerne lo stato ?
		[# 	ClearDish = PrepareDish 
			ClearFood = PrepareFood
		#]
		println ("RBR | executing task 'Clear the room':")
		println ("RBR | going to table...")
		forward table -m removeFood:removeFood($ClearFood)
		
		println ("RBR | ...reached table. Going to fridge...")
		forward fridge -m add:add($ClearFood)
		
		println ("RBR | ...reached fridge. Going to table...")
		forward table -m removeDishes:removeDishes($ClearDish)
		
		println ("RBR | ...reached table. Going to dishwasher...")
		forward dishwasher -m add:add($ClearDish)
		println ("RBR | ...reached dishwasher. Coming back to RH...")
		println ("RBR | ...reached RH. Finished executing task")
		terminate 0
	}
}
/* 
QActor maitre context ctxmaitre{
	[#	var AddFoodtime = 3000L 
		var Nexp = 0
		var PrepareDish = 0
		var PrepareFood = emptyArray<Int>()
		var FoodCode = 0
		
		val FridgeObserver = util.ActorCoapObserver("localhost",8040,"ctxsystem","fridge")
		val TableObserver = util.ActorCoapObserver("localhost",8040,"ctxsystem","table")
		val PantryObserver = util.ActorCoapObserver("localhost",8040,"ctxsystem","pantry")
		val DishwasherObserver = util.ActorCoapObserver("localhost",8040,"ctxsystem","dishwasher")
		
	#]	
	
	State s0 initial {
		[# 	PrepareDish = 20
			PrepareFood = arrayOf(1,2,3)
			FoodCode = 1
			
			FridgeObserver.activate(myself)
			TableObserver.activate(myself)
			PantryObserver.activate(myself)
			DishwasherObserver.activate(myself)
		#]
	
		delay 2000
		println ("MAITRE | STARTS")
	}Goto sendPrepare
	
	State sendPrepare {
		forward rbr -m prepare:prepare($PrepareDish, arrayOf(3,2,1))///PrepareDish;PrepareFood
		println ("MAITRE | send prepare command to RBR: $PrepareDish, $PrepareFood")		
	}
	Goto sendAddFood
		
	State sendAddFood {
		forward rbr -m addFood : addFood($FoodCode)
		println ("MAITRE | send addFood(Food_Code) command to RBR")	
	}
	Transition t1 
		whenTimeVar AddFoodtime -> sendConsult //time waiting for warning otherwise the food is present
		whenReply warning -> handleWarning
			
	State handleWarning {
		println ("MAITRE | received warning from RBR")
	}
	Goto sendConsult

	State sendConsult{	
		forward fridge -m consult : consult(0)
		println ("MAITRE | send consult command to Fridge")
		forward dishwasher -m consult : consult(0)
		println ("MAITRE | send consult command to Dishwasher")
		forward pantry -m consult : consult(0)
		println ("MAITRE | send consult command to Pantry")
		forward table -m consult : consult(0)
		println ("MAITRE | send consult command to Table")
	}
	Goto waitExpose

	State waitExpose{
		delay 500
		println("waiting answer from resource")
	}
	Transition t0 
		whenEvent observerdishwasher-> handleExpose
		whenEvent observerfridge-> handleExpose
		whenEvent observerpantry-> handleExpose
		whenEvent observertable-> handleExpose

	State handleExpose {
		[#  var Sender = currentMsg.msgSender()
			var AnsExpose = " "
			Nexp++ 
		#]
		onMsg( observerdishwasher:observerdishwasher(X) ) {
	 		[# AnsExpose= payloadArg(0) #]
 		}
 		onMsg( observerfridge:observerfridge(X) ) {
	 		[# AnsExpose= payloadArg(0) #]
 		}
 		onMsg( observerpantry:observerpantry(X) ) {
	 		[# AnsExpose= payloadArg(0) #]
 		}
 		onMsg( observertable:observertable(X) ) {
	 		[# AnsExpose= payloadArg(0) #]
 		}
 		
		println ("MAITRE | status of $Sender: $AnsExpose")
	}
	Goto sendClear if [# Nexp == 4 #]
		else 
		waitExpose
	
	State sendClear{
		forward rbr -m clear : clear(0)
		terminate 0
	}
}
*/
QActor pantry context ctxres{

	State s0 initial {
		println ("PANTRY| loading initial state ")
		solve(consult("PantryInit.pl"))	
	}Goto work
	
	State work{
		println ("PANTRY| working")
	}
	Transition t0
	whenMsg consult -> exposeState
	whenMsg add-> handleChangeState
	whenMsg remove -> handleChangeState
	
	State exposeState{
		[#var State = "c"#]

		println ("PANTRY | exposed content to maitre")
		//TODO[Prolog] operazione di lettura Status

		updateResource[#"State:$State"#]
	}Goto work
	
	State handleChangeState{
		[# var Nd = "" #]
		
		onMsg( add:add(X) ) { 
	 		[# 	Nd = payloadArg(0) #]
	 		println ("PANTRY | add $Nd...")
	 		[# //Dishes = Dishes + Nd  #]
			//TODO[Prolog] operazione scrittura
 		}
 		onMsg( remove:remove(X) ) { 
			[# 	Nd = payloadArg(0) #]
	 		println ("PANTRY| remove $Nd...")
	 		[# //Dishes = Dishes - Nd  #]
			//TODO[Prolog] operazione scrittura
 		}	
 	}Goto work	
}

QActor table context ctxres{
	// da decidere come rappresentare il cibo
	State s0 initial {
		println ("TABLE| loading initial state ") 
		solve(consult("TableInit.pl"))
	}Goto work
	
	
	State work{
		println ("TABLE| working")
	}
	Transition t0
	whenMsg consult -> exposeState
	whenMsg addDishes -> handleChangeState
	whenMsg removeDishes -> handleChangeState
	whenMsg addFood -> handleChangeState
	
	
	State exposeState{	
		[#var State = "b"#]

		println ("TABLE | exposed content to maitre")
		//TODO[Prolog] operazione di lettura Status

		updateResource[#"State:$State"#]
	}Goto work
	
	State handleChangeState{
		[#
			var Nd= 0
			var Fs =  emptyArray<Int>()
		#]

		onMsg( addFood:addFood(X) ) { //X valore
			[# Fs= payloadArg(0).map{ it.toInt() }.toTypedArray() #]
			//TODO[Prolog] operazione scrittura
	 		println ("TABLE| add $Fs...")
 		}

 		onMsg( removeFood:removeFood(X) ) { //X valore
			[# 	Fs = payloadArg(0).map{ it.toInt() }.toTypedArray() #]
			//TODO[Prolog] operazione scrittura
	 		println ("TABLE| remove $Fs...")
		}
		onMsg( addDishes:addDishes(X) ) { //X valore
			[# Nd= payloadArg(0).toInt() #]
	 		println ("TABLE| add $Nd...")
			//TODO[Prolog] operazione scrittura
	 		[# //Dishes = Dishes + Nd  #]
 		}
 		onMsg( removeDishes:removeDishes(X) ) { //X valore
			[# 	Nd = payloadArg(0).toInt()#]
			println ("TABLE| remove $Nd...")
			//TODO[Prolog] operazione scrittura
			[# //Dishes = Dishes - Nd  #]
  		}
	}Goto work
}

QActor dishwasher context ctxres{
	State s0 initial {
		println ("DISHWASHER| loading initial state ")
		solve(consult("DishwasherInit.pl"))
	}Goto work 
	
	State work{
		println ("DISHWASHER| working")
	}
	Transition t0
	whenMsg consult -> exposeState
	whenMsg remove-> handleChangeState
	whenMsg add-> handleChangeState
	
	State exposeState{
		[#var State = "d"#]

		println ("DISHWASHER | exposed content to maitre")
		//TODO[Prolog] operazione di lettura Status

		updateResource[#"State:$State"#]
 	}Goto work
	
	State handleChangeState{
		[# var Nd = ""	#]

		onMsg( add:add(X) ) { //X valore
			[# Nd= payloadArg(0) #]
	 		println ("DISHWASHER| add $Nd...")
	 		
			//TODO[Prolog] operazione scrittura
 		}
 		onMsg( remove:remove(X) ) { //X valore
			[# 	Nd= payloadArg(0)#]
	 		println ("DISHWASHER| remove $Nd...")
			//TODO[Prolog] operazione scrittura
 		}	
	}Goto work
}

QActor fridge context ctxfridge{

	State s0 initial {
		println ("FRIDGE | STARTS and it's embedded with the proper set of food")
		solve(consult("FridgeInit.pl"))
		delay 300
	}
	Goto wait

	State wait {
		println ("FRIDGE | is waiting for a command...")
	} 
	Transition t1 
		whenMsg add-> changeFood
		whenMsg remove -> changeFood
		whenMsg askFood -> answerFood
		whenMsg consult -> exposeState

	State changeFood{			
		[# var Food_Code = ""  #]
		
 		onMsg( add:add(X) ) { //X 
			[# Food_Code = payloadArg(0)#]
	 		println ("FRIDGE | add $Food_Code...")
			//TODO[Prolog] operazione scrittura
 		}
 		onMsg( remove:remove(X) ) { //X 
			[# Food_Code = payloadArg(0)#]
	 		println ("FRIDGE | remove $Food_Code...")
			//TODO[Prolog] operazione scrittura
 		}
	}Goto wait

	State answerFood {
		[# var Food_Code = "" 
		   var FoodPresence = false
		 #]
		onMsg( askFood:askFood(X) ) {
	 		[# Food_Code = payloadArg(0) #]
 		}
		println ("FRIDGE | searching Food_Code $Food_Code...")
		//TODO[Prolog] operazione di ricerca Food_Code

		updateResource[#"FoodPresence:$FoodPresence"#]		
	}
	Goto wait
	
	State exposeState {
		[#var State = "a"#]

		println ("FRIDGE | exposed content to maitre")
		//TODO[Prolog] operazione di lettura Status
		
		updateResource[#"State:$State"#]
	} 
	Goto wait		
}