System standingbuffetservice

// In the following model it's reported a first prototype of the system described by the requirements. 
// In particular are described the main interactions and the main behaviors between the main system components. 
// Cause some requirements are too advanced in this step the complete features are supported: 
// the stop/reactivate feature is just described as a dispatcher but is still not working cause none state read that message; 
// also the 'consult' task is still not complete cause the state information of smart and non smart elements should be managed, but in this representation it's just handled the fridge state information.
// The maitre is described as a mock client, it's early to represent his full proactive behavior that depend from a GUI.

//FIXME arguments dont't work
//Maitre-Fridge
Request consult:consult(ARG)
Reply expose:expose(STATUS)

//Maitre-RBR
Dispatch prepare:prepare(ARG)
Dispatch addFood:addFood(FOOD_CODE)
Dispatch clear:clear(ARG)

Dispatch stop:stop(ARG)
Dispatch reactivate:reactivate(ARG)

Dispatch warning:warning(ARG)

//RBR-Fridge
Request askFood:askFood(FOOD_CODE)
Reply answer:answer(FOOD_PRESENCE)

Context ctxRBR ip [host="localhost" port=8055]
Context ctxFridge ip [host="localhost" port=8056]
Context ctxMaitre ip [host="localhost" port=8057]

QActor rbr context ctxRBR {
	[# var FOOD_PRESENCE = false #]	
	
	State s0 initial {
		println ("RBR | STARTS and it's placed in RH position")
	}
	Transition t0
		whenMsg prepare -> exPrepare
		  
	State exPrepare {
		println ("RBR | executing task 'Prepare the room':")
		println ("RBR | going to pantry...")
		println ("RBR | ...reached pantry. Going to table...")
		println ("RBR | ...reached table. Going to fridge...")
		println ("RBR | ...reached fridge. Going to table...")
		println ("RBR | ...reached table. Coming back to RH...")
		println ("RBR | ...reached RH. Finished executing task")
	}
	Goto wait
	
	State wait {
		println ("RBR | is placed in RH position and it's waiting for a command...")
	}
	Transition t1
		whenMsg addFood -> checkFood
		whenMsg clear -> exClear
	  
	State checkFood {
		[# var FOOD_CODE = payloadArg(0) #]
		request fridge -m askFood:askFood($FOOD_CODE)
		println ("RBR | asked to fridge if it contains the food required")
	}
	Transition t2
		whenReply answer -> handleReply
		
	State handleReply {
	[# var FOOD_PRESENCE = payloadArg(0).toBoolean() #]	
	}
	Goto fail if [# FOOD_PRESENCE == false #] else exAddFood

	State fail {
		forward maitre -m warning:warning(0)
		println ("RBR | send warning to maitre")
	}
	Goto wait

	State exAddFood {
		println ("RBR | executing task 'Add food':")
		println ("RBR | going to fridge...")
		println ("RBR | ...reached fridge. Going to table...")
		println ("RBR | ...reached table. Coming back to RH...")
		println ("RBR | ...reached RH. Finished executing task")
	}
	Goto wait
	
	State exClear {
		println ("RBR | executing task 'Clear the room':")
		println ("RBR | going to table...")
		println ("RBR | ...reached table. Going to fridge...")
		println ("RBR | ...reached fridge. Going to table...")
		println ("RBR | ...reached table. Going to dishwasher...")
		println ("RBR | ...reached dishwasher. Coming back to RH...")
		println ("RBR | ...reached RH. Finished executing task")
	}
}

QActor fridge context ctxFridge {
	//TODO sistemare messaggi 
	[# 
		var FOOD_PRESENCE = false
		var STATUS = "Frigo vuoto"
	#]
	
	State s0 initial {
		println ("FRIDGE | STARTS and it's embedded with the proper set of food")
	}
	Goto wait
	
	State wait {
		println ("FRIDGE | is waiting for a command...")
	} 
	Transition t1 
		whenRequest askFood -> answerFood
		whenRequest consult -> exposeState

	State answerFood {
		println ("FRIDGE | searching food_code...")		
		replyTo askFood with answer:answer($FOOD_PRESENCE)
		println ("FRIDGE | answered to RBR about food")
	}
	Goto wait
	
	State exposeState {
		replyTo consult with expose:expose($STATUS)
		println ("FRIDGE | exposed content to maitre")
	} 
	Goto wait		
}

QActor maitre context ctxMaitre {

	State s0 initial {
		delay 5000
		println ("MAITRE | STARTS")
		
		forward rbr -m prepare : prepare(0)
		println ("MAITRE | send prepare command to RBR")
		
		forward rbr -m addFood : addFood(1500)
		println ("MAITRE | send addFood(food_code) command to RBR")	
	}
	Transition t1 
		whenTime 5000 -> s3
		whenMsg warning -> s2
		//FIXME: È opportuno parlare del timer nell'introduzione; è opportuno scriverlo meglio nel codice Es varibile = duration AddFood (è possibile farlo?)? 
			
	State s2 {
		println ("MAITRE | received warning from RBR: ${payloadArg(0)}")
	}
	Goto s3
	
	 
	State s3 {
		request fridge -m consult : consult(0) 
	}
	Transition t2
		whenReply expose -> s4	
	
	State s4 {
		println ("MAITRE | received expose from fridge: ${payloadArg(0)}")
		forward rbr -m clear : clear(0)
	}
}