System StandingBuffetService

**Event 	 consult	: consult(state_room)	//from maitre**

Dispatch robotCmd	: robotCmd(X) 	 		//from maitre to robot 
Dispatch fail		: fail(m)			 	//from robot to maitre
Dispatch ask 		: ask(foodCode) 		//from robot to fridge
Dispatch answer 	: answer(Y)			 	//from fridge to robot
Dispatch expose		: expose(state)  		//from fridge to maitre

Context ctxRobotReq ip [host="localhost" port=8000] 

~//requirements: maitre interaction, prepare, add food, clear, stop, reactive ~
Qactor maitrereq context ctxRobotReq 	{/* Provides a user GUI; Forwards robotCmd to robotreq */}

~//requirements: move RBR avoiding abstacles, ask to fridge ~
Qactor robotreq context ctxRobotReq 	{/* Moves the robot and avoid obstacles; Handle robotCmd and answer; Forwards ask to fridgereq and fail to maitrereq */}

~//requirements: expose, answer~
Qactor fridgereq context ctxRobotReq 	{/* Handle ask and consult; Forwards answer to robotreq and expose to maitrereq */}

System standingbuffetservice

/*3 main entities: RBR, maitre (that indicates the maitre's smartphone), fridge*/
init {
	RBR in RH;
	maitre in room;
	fridge, pantry: full;
	dishwasher, table: empty;
}

/* possible commands between entities: */
maitre to RBR : robotCmd [prepare, addFood(food-code), clear, stop, reactivate]
RBR to fridge : askFood(food-code)
fridge to RBR : answer
RBR to maitre : warning
maitre to all/fridge : consult
fridge to maitre : expose

/* 1° step: maitre send prepare command to RBR
	2° step: maitre can sand addFood(food-code) or clear command to RBR
				during this step the maitre can also send consult command (to fridge) or stop command to RBR (only if RBR is running a task)
	3° step:
				if maitre had send addFood(food-code) command to RBR --> RBR send askFood(food-code) command to fridge
				if maitre had send stop command to RBR --> maitre can send reactivate command to RBR --> step 2
				if maitre had send consult command (to fridge) --> fridge send expose command to maitre, (have to decide the handle of how to know the state of other elements in the room
				if maitre had send clear command to RBR --> END OF SYSTEM (after RBR had executed the task)
	4° step: if RBR had send askFood(food-code) command to fridge --> fridge send answer command to RBR
	5° step: if fridge had send answer command to RBR --> RBR can send warning command to maitre --> step 2*/

	/* Qak Actors */
/*From the requirements analysis, using a meta-model written in a machine-understandable language, like QActor, it's possible to obtain an univoque representation of the system architecture. In , the three main entities are represented by three actors and the nodes where they run are three context.<br>
Then, it's possible to realize a first model of this system architecture that is an initial representation of this system.
<br>
// In the following model it's reported a first prototype of the system described by the requirements. 
// In particular are described the main interactions and the main behaviors between the main system components. 
// Cause some requirements are too advanced in this step we don't support the complete features: 
// the stop/reactivate feature is just described as a dispatcher but is still not working cause none state read that message; 
// also the 'consult' task is still not complete cause we would manage the state information of smart and non smart elements, but in this representation we are just handle the fridge state information.
// The maitre is described as a mock client, it's early to represent his full proactive behavior that depend from a GUI.
<br>
QActors: modeling language that should help application designer in defining working models of distributed systems based on actors that behave as Finite State Machines. 
The QActor metamodel does not envisage any explicit receive operation, since the behavior is modeled as a Moore state machine in which state transitions are triggered by messaged and events.
<br>
A QA-System is a collection of active entities (QActors) each working in a computational node (Context).<br>
QActors interact by using Messages of different types (Dispatch, Request,...) and Events.
In the QActor metamodel, a message is intended as information sent in asynchronous way by some source to some specific destination.
For asynchronous transmission we intend that the messages can be 'buffered' by the infrastructure, while the 'unbuffered' transmission is said to be synchronous.
In the QActor metamodel, an event is intended as information emitted by some source without any explicit destination.
Events whose identifier start with the prefix local_ are not propagated outside the context in which they are generated.<br>
Each context owns a set QActors that can interact with components (actors or 'aliens') working on a different node, by means of the following protcols:
TCP : on the port specified by the Context
CoAP : on the port specified by the Context
MQTT : using the broker specified in the mqttBroker declaration.
Each QActor works in a context that provides support for sending-receiving messages on the network, by means of several types of protocols.<br>

A QAkactor named qa working in a context named ctxqa can be accessed as a CoAP resource with URI-path ctxqa/qa. and works as a (CoAP) observable resource.
The current state of the resource can be stored as a String in the variable ActorResourceRep, by using the operation updateResource of the QAkactor language.*/
