<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<link rel="stylesheet" type="text/css" href="./utils/style.css">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<base href=".">
<title>RomeoRussoStandingBuffetService</title>
</head>

<body>

<div id="top">
<h1>STANDING BUFFET SERVICE | Ingegneria dei Sistemi Software</h1>
</div>

<div class="body">

<h2>Introduction</h2>

Keeping in mind the motto: <bc>"there is no code without a project, no project without problem analysis and no problem without requirements"</bc>, this document presents a possible solution to the requirements provided by the customer, achieved with a top-down approach in three main phase: requirements analysis, problem analysis and a design phase.

<h2><a name="requirements"></a>Requirements</h2>

<div class="remark">
Below it's shown the <a href="./utils/tf/TemaFinaleBo19.html" target="_blank">requirements text</a> provided by the customer.<br>
<br>
<iframe src="./utils/tf/TemaFinaleBo19.html" title="Requirements text"><a href="./utils/tf/TemaFinaleBo19.html" target="_blank">Requirements Text Link</a></iframe>
</div>

<h2>Requirement Analysis</h2>

<h3>Glossary</h3>

By the interaction with the customer, here it's exposed an essential glossary about the meaning of the names and of the verbs included in the <a href="./Analysis.html#requirements">requirements text</a> given by the customer.
<br><br>
<table>
<tr>
	<td class="title"><ks>room</ks></td>
	<td>It's an environment equipped with a set of smart and non-smart resources and in which the interactions between these elements happen. These resources are: a <ks>pantry</ks>, a <ks>dishwasher</ks> and a <ks>fridge</ks>, that are all embedded into the wall of the room; a <ks>table</ks>, that is placed in the center of the room; an <ks>RBR</ks>. When system starts no people is in it, besides the <ks>Maître de Salle</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>Maître de Salle</ks></td>
	<td>Person who manages the <ks>room</ks> and its elements, using the <ks>maître's smartphone</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>maître's smartphone</ks></td>
	<td>Smartphone application or a user-GUI in a browser used by <ks>Maître de Salle</ks> to interact with smart resources in the <ks>room</ks> (<ks>fridge</ks> and <ks>RBR</ks>).</td>
</tr>
<tr>
	<td class="title"><ks>fridge</ks></td>
	<td>It's a smart device, having knowledge base on his storage, and an "Internet Thing". It's embedded into the wall of the <ks>room</ks> and it's filled with a proper set of items when system starts. It must be able to communicate, via <tt>CoAP</tt>, with <ks>maître's smartphone</ks> and <ks>RBR</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>pantry</ks></td>
	<td>It's a non-smart resource embedded into the wall of the <ks>room</ks> and it's filled with a proper set of items when system starts.</td>
</tr>
<tr>
	<td class="title"><ks>dishwasher</ks></td>
	<td>It's a non-smart resource embedded into the wall of the <ks>room</ks> and it's empty when system starts.</td>
</tr>
<tr>
	<td class="title"><ks>table</ks></td>
	<td>It's a non-smart resource put in the center of the <ks>room</ks> and it's empty when system starts.</td>
</tr>
<tr>
	<td class="title"><ks>RBR - <i>Room Butler Robot</i></ks></td>
	<td>It's a <ks>DDR</ks> able to work as a Room Butler: it must be able to communicate with <ks>maître's smartphone</ks> and <ks>fridge</ks> and to walk around the <ks>room</ks> to execute the <ks>task</ks>, avoiding the fixed and mobile obstacles. When system starts and after it completed a <ks>task</ks>, it must wait new commands in the <ks>RH</ks> position.</td>
</tr>
<tr>
	<td class="title"><ks>DDR - <i>Differential Drive Robot</i></ks></td>
	<td>The customer provided all the documentation about this topic: the documentation about the <tt>basicRobot</tt> (at <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html" target="_blank">basicrobot2021.html</a>), that can be implemented as a <tt>virtual robot</tt> (at <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html" target="_blank">VirtualRobot2021.html</a>) or as a real robot, that can be an <tt>mbot</tt> (at <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/Mbot2020.html" target="_blank">MBot2020.html</a>) or a <tt>nano robot</tt> (at <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/LabNanoRobot.html" target="_blank">LabNanoRobot.html</a>).</td>
</tr>
<tr>
	<td class="title"><ks>RH - <i>Robot Home</i></ks></td>
	<td>It's the position in the <ks>room</ks> where the <ks>RBR</ks> boots up and where he comes back after every <ks>task</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>task</ks></td>
	<td>it's a task that the <ks>RBR</ks> must execute when required by <ks>Maître de salle</ks> via <ks>maître's smartphone</ks>. There are three possible tasks, that are mutually exclusive and that must be executed in this order: <ks>Prepare the room</ks>, <ks>Add food</ks> and finally <ks>Clear the room</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>Prepare the room</ks></td>
	<td>This <ks>task</ks> consists in putting on the <ks>table</ks> dishes taken from the <ks>pantry</ks> and food taken from the <ks>fridge</ks>. The set of items to put on the <ks>table</ks> is fixed and it's properly described somewhere.</td>
</tr>
<tr>
	<td class="title"><ks>Add food</ks></td>
	<td>This <ks>task</ks> consists in putting on the <ks>table</ks> some specific food (defined by a <ks>food-code</ks>) taken from the <ks>fridge</ks> if it exists.</td>
</tr>
<tr>
	<td class="title"><ks>food-code</ks></td>
	<td>Univoque code associated to a specific food.</td>
</tr>
<tr>
	<td class="title"><ks>Clear the room</ks></td>
	<td>This <ks>task</ks> consists in putting in the <ks>fridge</ks> and in the <ks>dishwasher</ks> respectively non-consumed food and dishes taken from the <ks>table</ks>.</td>
</tr>
</table>

<h3>Requirements Analysis</h3>

Once we have understood the main concepts set by the <a href="./Analysis.html#requirements">requirements text</a> given by the customer, it's now possible to analyze them.
<br><br>
<table>
<tr>
	<td>The software system is a distribuited system composed by three main entities:
	<ul>
		<li><ks>RBR</ks>, running on its own <kc>robotNode</kc>;</li>
		<li><ks>maître's smartphone</ks>, running on a <kc>maitreNode</kc>;</li>
		<li><ks>fridge</ks>, running on a <kc>fridgeNode</kc>.</li>
	</ul>
	</td>
	<td class="image"><img src="./utils/img/ReqAnalysis/threeEntities.png" alt="Three entities"></td>
</tr>
<tr>
	<td>The software running on <kc>maitreNode</kc> must allow <ks>Maître de Salle</ks> to:
	<ul>
		<li>send the commands to <ks>RBR</ks> to execute <ks>tasks</ks> or to stop and reactivate them (only if there are already activated <ks>tasks</ks>);</li>
		<li>known and to show the objects related to each resources, smart (<ks>fridge</ks>) and non-smart(<ks>pantry</ks>, <ks>dishwasher</ks>, <ks>table</ks>), so it must be able to communicate with <ks>fridge</ks> too.</li>
	</ul>
	</td>
	<td class="image" rowspan="3"><img src="./utils/img/ReqAnalysis/entitiesRel.png" alt="Relationships between entities"></td>
</tr>
<tr>
	<td>The software running on <kc>robotNode</kc> must be able to:
	<ul>
		<li>execute the <ks>task</ks> associated to command received by the <ks>maître's smartphone</ks>;</li>
		<li>stop/reactivate a running <ks>task</ks> when it's required by the <ks>maître's smartphone</ks>;</li>
		<li>ask <ks>fridge</ks> if it contains a specific food defined by a <ks>food-code</ks> and to receive the answer;</li>
		<li>send a warning to the <ks>maître's smartphone</ks> when the <ks>fridge</ks> doesn't contain the food required;</li>
		<li>return to his <ks>RH</ks> at the end of every <ks>task</ks>;</li>
		<li>avoid the impact with obstacles.</li>
	</ul>
	</td>
</tr>
<tr>
	<td>The software running on <kc>fridgeNode</kc> must be able to:
		<ul>
		<li>answer to the <ks>maître's smartphone</ks>, via <tt>CoAP</tt>, with his content when it's required;</li>
		<li>answer to the <ks>RBR</ks>, via <tt>CoAP</tt>, when it asks if it contains a specific food defined by a <ks>food-code</ks>.</li>
		</ul>
	</td>
</tr>
</table>

<h3>A First Set of Functional Test Plans</h3>

<h4>Scenario</h4>

Here, it's illustrated a possible scenario of the system.
<br><br>
<table>
<tr class="text">
	<th>Steps in the Scenario</th>
	<th>Simplified Representation of Each Step</th>
</tr>
<tr>
	<td><ol><li>The <ks>room</ks> is empty, beside the <ks>Maître de Salle</ks>. The <ks>RBR</ks> is on its <ks>RH</ks>. The <ks>fridge</ks> and the <ks>pantry</ks> are embedded with a proper set of items; while the <ks>dishwasher</ks> and the <ks>table</ks> are empty.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ReqAnalysis/InitialScenario.png" alt="Initial scenario"></td>
</tr>
<tr>
	<td><ol start="2"><li>The <ks>Maître de Salle</ks> sends the <em>prepare</em> command (for the <ks>task</ks> <ks>Prepare the room</ks>) to the <ks>RBR</ks> and waits. The <ks>RBR</ks> executes the <ks>task</ks> related to the command and at the end he returns to its <ks>RH</ks>.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ReqAnalysis/ScenarioPrepare.png" alt="Scenario 'Prepare the room'"></td>
</tr>
<tr>
	<td><ol start="3"><li>The party starts and the <ks>room</ks> is opened to people: so now there are other obstacoles in the <ks>room</ks>. The <ks>Maître de Salle</ks> can send at any time to <ks>RBR</ks> the <em>addFood (food-code)</em> command (for the <ks>task</ks> <ks>Add food</ks>). The <ks>RBR</ks> asks <ks>fridge</ks> if it has the food specified by <ks>food-code</ks> and the <ks>fridge</ks> <em>answers</em> to <ks>RBR</ks>, via <tt>CoAP</tt>. If the <ks>fridge</ks> doesn't contain that food, then the <ks>RBR</ks> sends a <em>warning</em> to the <ks>Maître de Salle</ks>; otherwise the <ks>RBR</ks> executes the <ks>task</ks> and then he returns to its <ks>RH</ks>.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ReqAnalysis/ScenarioAddFood.png" alt="Scenario 'Add food'"></td>
</tr>
<tr>
	<td><ol start="4"><li>At the end of the party the <ks>room</ks> is empty again, beside the <ks>Maître de Salle</ks>. The <ks>Maître de Salle</ks> sends to <ks>RBR</ks> the <em>clear</em> command (for the <ks>task</ks> <ks>Clear the room</ks>) and waits. The <ks>RBR</ks> executes the <ks>task</ks> and then he returns to its <ks>RH</ks>.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ReqAnalysis/ScenarioClear.png" alt="Scenario 'Clear the room'"></td>
</tr>
<tr>
	<td colspan="2">At every time of the service:
	<ul>
		<li>The <ks>Maître de Salle</ks> can use <em>consult</em> command to know the state of each element in the <ks>room</ks> (<ks>fridge</ks>, <ks>pantry</ks>, <ks>dishwasher</ks>, <ks>table</ks>). In this case, the <ks>fridge</ks> answers via <tt>CoAP</tt>, <em>exposing</em> its content.</li>
		<li>The <ks>Maître de Salle</ks> can use the <em>stop</em> or <em>reactivate</em> command to stop or restart an already activated <ks>task</ks>, otherwise these commands have no effect.</li>
		<li>The <ks>RBR</ks> must <em>avoid</em> the obstacles.</li>
	</ul>
	</td>
</tr>
</table>

<h4><a name="reqATP"></a>Test Plans</h4>

It's necessary to make some test plans that must be verified for the correct working of the final system, according to the requirements provided by the customer.
<br>Below it's reported a first planning of tests:
<br><br>
<ul>
	<li>Tests of the position of the <ks>RBR</ks> that must be on its <ks>RH</ks> when system starts and at the end of each <ks>task</ks>;</li>
	<li>Tests of the states for each element (<ks>fridge</ks>, <ks>pantry</ks>, <ks>dishwasher</ks>, <ks>table</ks>) in the <ks>room</ks> in every moment of the service (start, end, end <ks>task</ks>, <em>consult</em> command);</li>
	<li>Tests of all the communications between entities;</li>
	<li>Tests of the path carried out by the <ks>RBR</ks> that must be the one expected to execute the <ks>task</ks> required by the <ks>Maître de Salle</ks>;</li>
	<li>Tests of the mutual exclusion of <ks>tasks</ks> and of their order of execution;</li>
	<li>Tests of the state of the <ks>RBR</ks> to verify that it is stopped after receiving <em>stop</em> command and to verify that it resumes <ks>task</ks> execution after receiving the <em>reactivate</em> command;</li>
	<li>Tests of the <em>stop</em> and <em>reactivate</em> commands that can be used by <ks>Maître de salle</ks> only when there is a running <ks>task</ks>;</li>
	<li>Test of the capability of the <ks>RBR</ks> to <em>avoid</em> all the possible obstacles.</li>
</ul>

<h3><a name="ReqAnModel"></a>A First Model of the System Architecture</h3>

From the requirements analysis, it's possible to obtain a first model, that is an initial representation of the system architecture, using a meta-model written in a machine-understandable language, like <tt>QActor</tt>, that describes the main interactions and behaviors between the main system components. In particular, the three main entities (<ks>RBR</ks>, <ks>maître's smartphone</ks>, <ks>fridge</ks>) are represented by three <tt>actors</tt> (<tt>QActors</tt>, that behave as <tt>Finite State Machines</tt> and work as <tt>CoAP</tt> observable resources) (<k>rbr</k>, <k>maitre</k>, <k>fridge</k>) and the nodes (<kc>robotNode</kc>, <kc>maitreNode</kc>, <kc>fridgeNode</kc>) where they run are represented by <tt>contexts</tt> (<k>ctxRBR</k>, <k>ctxMaitre</k>, <k>ctxFridge</k>).
<br><br>
To make this, there were been found some problems, that will be addressed and solved next in the problem analysis:
<ul>
	<li>the <em>stop</em> and <em>reactivate</em> features;</li>
	<li>the <em>consult</em> feature, that is still not completed cause it's necessary to manage the state of smart and non-smart elements, but in this representation it's handled only the <k>fridge</k> state;</li>
	<li>the <ks>fridge</ks> requirement to reply via <tt>CoAP</tt> to <k>rbr</k> or <k>maitre</k>, that isn't yet implemented but it's handled in this first phase through a <ko>dispatch</ko> message;</li>
	<li>the movements of the <ks>RBR</ks>, that aren't addressed here but only its interactions with <k>fridge</k> and <k>maitre</k>;</li>
	<li>the <ks>maître's smartphone</ks>, that is described here as a <tt>mock client</tt>, because it's early, in the requirements analysis, to represent his full proactive behavior that depends from a <tt>GUI</tt>.</li>
</ul>
<br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text" rowspan="3">
		<a href="./ReqAnalysisModel.qak" target="_blank">ReqAnalysisModel.qak</a><br>
		<pre><iframe class="qakReq" src="./ReqAnalysisModel.qak" title="ReqAnalysisModel">Model of Requirements Analysis</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ReqAnalysis/FirstModelFromReqAnalysis.png" alt="Representations of the system from Requirements Analysis">
	</td>
</tr>
<tr class="text">
	<th>Moore State Machine Diagram</th>
</tr>
<tr>
	<td class="imageSchema">
		<img src="./utils/img/ReqAnalysis/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
		<img src="./utils/img/ReqAnalysis/QActorMaitre.png" alt="Representation of the behavior of QActor maitre, modeled as a Moore state machine"><br>
		<img src="./utils/img/ReqAnalysis/QActorRBR.png" alt="Representation of the behavior of QActor rbr, modeled as a Moore state machine"><br>
		<img src="./utils/img/ReqAnalysis/QActorFridge.png" alt="Representation of the behavior of QActor fridge, modeled as a Moore state machine">
	</td>
</tr>
</table>

<h2><a name="ProblemAn"></a>Problem Analysis</h2>

<h3>Identification of the Problems and the Corresponding Solutions</h3>

Starting from the requirements analysis, it's now necessary to found the main problems and abstraction gap involved by the requirements and to solve them, establishing the most appropriate technologies necessary for building the system.
<dl>
	<dt>General System</dt>
	<dd>In the requirements analysis, there were been identified three main entities that run on different nodes, therefore the system is distribuited. To model it, it's available the <tt>Qak-infrastructure</tt>, provided by the <m>it.unibo.qakactor-2.4.jar</m> library. This framework provides a built-in message-driven tecnology to support the communications between different <tt>actors</tt> running on different <tt>contexts</tt>. In this way, it's possible to design the main components of the system using <tt>QActor</tt> meta-model.</dd>
	<br>
	<dd>To support the distribuited communications, it's possible to use the <tt>TCP</tt>, <tt>MQTT</tt> and/or <tt>CoAP</tt> protocols; the last one, by requirements, must be used by the <k>fridge</k> to communicate with the other two main components. In particular, <tt>MQTT</tt> is a IoT optimized messagging protocol which allows to implement a publish/subscribe interaction; while <tt>CoAP</tt> is a protocol for point-to-point communications among different nodes on the same network. <tt>CoAP</tt> supports also the <i>observe mechanism</i> where the node state is seen as a resource (<tt>CoAP</tt>) observed by other <tt>CoAP</tt> clients.</dd>
	<br>
	
	<dt>Fridge</dt>
	<dd>The requirements specify that the <k>fridge</k> must communicate through <tt>CoAP</tt> protocol. This can be done updating the <k>fridge</k> state through the <ko>updateResource</ko> command provided by the <tt>Qak-infrastructure</tt> and using a <tt>CoAP observer</tt> which waits for a <k>fridge</k> state update and when this happens, it sends an <ko>event</ko> to the listening actors.</dd>
	<br>
	
	<dt>Resources</dt>
	<dd>In the <ks>room</ks> there are non-smart resources, whose communications with other system components could be managed:
		<ol>
			<li><a name="sol1_coap"></a>via <tt>CoAP</tt>, as for <k>fridge</k> resource;</li>
			<li>through messages, like <ko>dispatch</ko> or <ko>request</ko>/<ko>reply</ko>.</li>
		</ol>
	For uniformity in the management of all resources (smart and non-smart), the most indicated solution could be the <a href="./Analysis.html#sol1_coap">first one</a>.<dd>
	<br>
	<dd>The states of non-smart resources should be managed by the software system. This could be done in different ways, listed below.
	<br><br>
	<table>
	<tr>
		<td><ol><li>Using a resource manager <tt>actor</tt> (<k>rm</k>) which manages the state of each non-smart resource. It receives the <em>consult</em> command from <k>maitre</k> and answers it, via <tt>CoAP</tt>, <em>exposing</em> the state of each non-smart resource. Moreover, when the <k>rbr</k> executes the <ks>tasks</ks>, it interacts with the <k>rm</k> to change the state of each non-smart resource.
		<dl>
			<dt>Pro:</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li>easy for <k>maitre</k> to obtain the state of each resource, sending <em>consult</em> command to <k>rm</k> and <k>fridge</k>.</li>
			</ul></dd>
			<dt>Cons:</dt>
			<dd><ul>
				<li>the <k>rm</k> has to manage the state for every non-smart resource and this can result a concectually intricate operation when it must update a resource state at request of <k>rbr</k>.</li>
			</ul></dd>
		</dl>
		</li></ol></td>
		<td class="imageScenario"><img src="./utils/img/ProblemAnalysis/ResourcesStatusManagement_type1_model.png" alt="ResourcesStatusManagement_type1_model"></td>
	</tr>
	<tr>
		<td><ol start="2"><li>Using a resource manager <tt>actor</tt> (<k>rm</k>) which manages the state of each resource (smart and non-smart). It works as an intermediary between the <k>maitre</k> (which sends it the <em>consult</em> command to know the state of each resource) or the <k>rbr</k> (which interacts with it to change the state of each resource, during the execution of each <ks>task</ks>) and the other resources. In this way, the <k>rm</k> will know the states of non-smart resources and it will communicate with <k>fridge</k> to know its state.
		<dl>
			<dt>Pro:</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li>easy for <k>maitre</k> to obtain the state of each resource, only sending <em>consult</em> command to the <k>rm</k>;</li>
				<li><k>rm</k> is the only component that manages the resources and this brings to a cleaner architecture.</li>
			</ul></dd>
			<dt>Cons:</dt>
			<dd><ul>
				<li>the <k>rm</k> has to manage the state for every non-smart resource and this can result a concectually intricate operation when it must update a resource state at request of <k>rbr</k>;</li>
				<li>when <k>rbr</k> wants to change the state of the <k>fridge</k> there is one more step: the <k>rbr</k> must communicate with <k>rm</k>, which communicates to <k>fridge</k> the desired change.</li>
			</ul></dd>
		</dl>
		</li></ol></td>
		<td class="imageScenario"><img src="./utils/img/ProblemAnalysis/ResourcesStatusManagement_type2_model.png" alt="ResourcesStatusManagement_type2_model"></td>
	</tr>
	<tr>
		<td><a name="sol3_msr"></a><ol start="3"><li>Managing the state of each non-smart resource using dedicated <tt>actors</tt>. In this way, the <k>maitre</k>, to know the state of each resource (smart and non-smart) sends to each <tt>actor</tt> the <em>consult</em> command. At the same way, when the <k>rbr</k> executes the <ks>tasks</ks>, it interacts with each <tt>actor</tt> to change the state of each resource.
		<dl>
			<dt>PRO</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li><k>rbr</k> can communicate directly with the resource <tt>actor</tt> of which it wants to change the state.</li>
			</ul></dd>
			<dt>CONS</dt>
			<dd><ul>
				<li>because of the simplicity of non-smart resources, their representation through <tt>actors</tt> could result a computational resources waste;</li>
				<li>the <k>maitre</k> has to send a <em>consult</em> command for each resource <tt>actor</tt> and to wait for each reply.</li>
			</ul></dd>
		</dl>
		</li></ol></td>
		<td class="imageScenario"><img src="./utils/img/ProblemAnalysis/ResourcesStatusManagement_type3_model.png" alt="ResourcesStatusManagement_type3_model"></td>
	</tr>
	<tr>
		<td><ol start="4"><li>Managing the state of each non-smart resource using dedicated <tt>actors</tt> and using a resource manager <tt>actor</tt> (<k>rm</k>) which manages the state of each resource (smart and non-smart). It works as an intermediary between the <k>maitre</k> (which sends it the <em>consult</em> command to know the state of each resource) or the <k>rbr</k> (which interacts with it to change the state of each resource, during the execution of each <ks>task</ks>) and the other resources <tt>actors</tt>. In this way, the <k>rm</k> will communicate with <k>fridge</k> and the other non-smart resource <tt>actors</tt> to know their states.
		<dl>
			<dt>PRO</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li>the <k>maitre</k> delegates the <k>rm</k> for the manage of all the resources;</li>
				<li>the <k>rbr</k> delegates the <k>rm</k> for the state change of each resource.</li>
			</ul></dd>
			<dt>CONS</dt>
			<dd><ul>
				<li>because of the simplicity of non-smart resources, their representation through <tt>actors</tt> could result a computational resources waste;</li>
				<li>the <k>rm</k> has to send a <em>consult</em> command for each resource actor and to wait for each reply; then it must communicate the result to <k>maitre</k>;</li>
				<li>the <k>rm</k> must communicate with each resource <tt>actor</tt> when <k>rbr</k> requires for a state change;</li>
				<li>the <k>rm</k> works only as an intermediary from <k>maitre</k> or <k>rbr</k> and resource <tt>actors</tt>. It does the work of <k>maitre</k> and <k>rbr</k> adding a step; so it results not useful.</li>
			</ul></dd>
		</dl>
		</li></ol></td>
		<td class="imageScenario"><img src="./utils/img/ProblemAnalysis/ResourcesStatusManagement_type4_model.png" alt="ResourcesStatusManagement_type4_model"></td>
	</tr>
	<tr>
	<td><ol start="5"><li>Managing the state of each non-smart resource using dedicated <tt>actors</tt> and using a resource manager <tt>actor</tt> (<k>rm</k>) which manages the state of each resource (smart and non-smart). At system start, there is a registration protocol where each resource try to subscribe it-self to <k>rm</k>; so to make the system more dynamic and ready at future resource add. The <k>rm</k> works as an intermediary between the <k>maitre</k> (which sends it the <em>consult</em> command to know the state of each resource) or the <k>rbr</k> (which interacts with it to change the state of each resource, during the execution of each <ks>task</ks>) and the other resources <tt>actors</tt>. In this way, the <k>rm</k> will communicate with <k>fridge</k> and the other non-smart resource <tt>actors</tt> to know their states.
	<dl>
		<dt>PRO</dt>
		<dd><ul>
				<li>easy to implement;</li>
				<li>the <k>maitre</k> delegates the <k>rm</k> for the manage of all the resources;</li>
				<li>the <k>rbr</k> delegates the <k>rm</k> for the state change of each resource;</li>
				<li>the presence of a registration protocol makes the system more dynamic and ready at future resource add.</li>
		</ul></dd>
		<dt>CONS</dt>
		<dd><ul>
			<li>because of the simplicity of non-smart resources, their representation through <tt>actors</tt> could result a computational resources waste;</li>
			<li>the <k>rm</k> has to send a <em>consult</em> command for each resource <tt>actor</tt> and to wait for each reply; then it must communicate the result to <k>maitre</k>;</li>
			<li>the <k>rm</k> must communicate with each resource <tt>actor</tt> when <k>rbr</k> requires for a state change.</li>
		</ul></dd>
	</dl>
	</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ProblemAnalysis/ResourcesStatusManagement_type5_model.png" alt="ResourcesStatusManagement_type5_model"></td>
	</tr>
	</table><br>
	Therefore, exposed some possible solutions, the most appropriate seems to be the <a href="./Analysis.html#sol3_msr">number 3</a>, because it makes the most of the message communication system and allows to extend the functioning of the <tt>actors</tt> if the resources they represent, in future, assume a more advanced behavior.</dd>
	<br>
	<dd>By requirement, at system start, <ks>fridge</ks> and <ks>pantry</ks> resources are embedded with a proper set of items and <ks>dishwasher</ks> and <ks>table</ks> resources are empty; so it's necessary an initialization procedure which loads the initial state for each resource (smart and non-smart) with its own elements set. To do this, it's possibile to use different approaches.
	<br><br>
	<table>
	<tr>
	<td><ol><li>Inserting resources initial state data directly in the code.
	<dl>
		<dt>PRO</dt>
		<dd><ul>
				<li>easy to implement.</li>
		</ul></dd>
		<dt>CONS</dt>
		<dd><ul>
			<li>the resources state is fixed in the code and this isn't a good practice, because it makes the code dirty;</li>
			<li>difficult to create mock states for testing.</li>
		</ul></dd>
	</dl>
	</li></ol></td>
	</tr>
	<tr>
	<td><ol start="2"><li>Using a text file for each resource (smart and non-smart), where to read data of the initial state of each resource.
	<dl>
		<dt>PRO</dt>
		<dd><ul>
				<li>separation between code and data; so to have a more clean code;</li>
				<li>easy to create mock states for testing.</li>
		</ul></dd>
		<dt>CONS</dt>
		<dd><ul>
			<li>it's necessary to introduce the read from text file functionality (load the resource state) to implement this solution.</li>
		</ul></dd>
	</dl>
	</li></ol></td>
	</tr>
	<tr>
	<td><a name="sol3_isr"></a><ol start="3"><li>Availing the <tt>Prolog</tt> functionality made available by the <tt>Qak-infrastructure</tt>. In this way, the resources initial state is represented by <tt>facts</tt> in a <tt>prolog</tt> file (one for each resource <tt>actor</tt>), which can be load through the <ko>consult</ko> command provided by the <tt>Qak-infrastructure</tt>, specifying the <tt>prolog</tt> file name.
	<dl>
		<dt>PRO</dt>
		<dd><ul>
				<li>separation between code and data; so to have a more clean code;</li>
				<li>easy to create mock states for testing;</li>
				<li>the <tt>Prolog</tt> support is already built-in the <tt>Qak-infrastructure</tt>.</li>
		</ul></dd>
		<dt hidden="hidden">CONS</dt>
		<dd hidden="hidden"><ul>
			<li></li>
		</ul></dd>
	</dl>
	</li></ol></td>
	</tr>
	<tr>
	<td><ol start="4"><li>Using a <tt>database (DB)</tt> to load the initial state of each resource.
	<dl>
		<dt>PRO</dt>
		<dd><ul>
				<li>separation between code and data; so to have a more clean code;</li>
				<li>easy to create mock states for testing;</li>
				<li>possibility to manage the state persistence, using well known patterns.</li>
		</ul></dd>
		<dt>CONS</dt>
		<dd><ul>
			<li>it's necessary to install a <tt>database</tt> server and to manually implement the access.</li>
		</ul></dd>
	</dl>
	</li></ol></td>
	</tr>
	</table><br>
	Therefore, exposed some possible solutions, the most appropriate seems to be the <a href="./Analysis.html#sol3_isr">number 3</a>, because it integrates best with the <tt>Qak-infrastructure</tt> and it is easier to implement and manage. In future, it could be ever integrated the possibility to add in the <ks>maître's smartphone</ks> software application a configuration tool, so to make possible for the <ks>Maître de Salle</ks> to insert or change the initial state values for each resource in the <ks>room</ks>.</dd>
	<br>
	<dd>To manage the update of the state value of each resource, there are two possible solutions:
	<ol>
		<li>to load at the start of each resource <tt>actor</tt> its initial state value from the <tt>prolog</tt> file and to save it in a variable, which will represent the resource state value and which will be updated when necessary;</li>
		<li><a name="sol2_uff"></a>to load at the start of each resource <tt>actor</tt> its initial state value from the <tt>prolog</tt> file and to update it when necessary, through the <ko>solve</ko> command provided by the <tt>Qak-infrastructure</tt>, which executes specific methods in the <tt>prolog</tt> file.</li>
	</ol>
	The solution adopted is the <a href="./Analysis.html#sol2_uff">second</a>, so as to make the most of the integration between <tt>Prolog</tt> and the <tt>Qak-infrastructure</tt>.</dd>
	<br>
	
	<dt><a name="PrAnTable"></a>Table</dt>
	<dd>An other problem could be represented from the management of the food consumption on the <ks>table</ks>. To do this, it's possibile to use different approaches:
	<ol>
		<li>using, for each food state on the <k>table</k>, a random consumption time, at the end of which the corresponding food will be consumed and therefore will be no longer available on the <k>table</k>;</li>
		<li>simulating people in the <ks>room</ks>, which consume the food on the <ks>table</ks> randomly, so as to make it no longer available on the <k>table</k>. This solution simulates what might actually happen in the <ks>room</ks> with regard to the consumption time, but not for the <k>table</k> state update, which would be delegated to each consumer. Furthermore, this simulation would make the system heavier;</li>
		<li>making that the <ks>Maître de Salle</ks> indicates when and which foods were consumed, in order to update the state of that food making it no longer available on the <k>table</k>.</li>
	</ol>
	The choose of a possible solution will be addressed next during the design phase after a consultation with the customer.</dd>
	<br>
	
	<dt><a name="PrAnRBR"></a>RBR</dt>
	<dd>To allow <k>rbr</k> to move, the customer provides a library <m>it.unibo.qak21.basicrobot-1.0.jar</m>. In particular, this framework provides the <tt>basicRobot</tt> (<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html" target="_blank">basicrobot2021.html</a>) and its possible implementations: <tt>virtual robot</tt> (<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html" target="_blank">VirtualRobot2021.html</a>), on its own <tt>WEnv</tt> (Web Environment), or real robot, that can be <tt>mbot</tt> (<a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/Mbot2020.html" target="_blank">MBot2020.html</a>) or <tt>nano robot</tt> (<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/LabNanoRobot.html" target="_blank">LabNanoRobot.html</a>).
	<br>
	Therefore to move the <k>rbr</k> must communicate through messages (<ko>dispatch</ko> or <ko>request</ko>) with the <tt>actor</tt> <k>basicrobot</k>, which performs the movements.</dd>
	<br>
	<dd>To execute the <ks>tasks</ks>, the <k>rbr</k> must be able to reach every element in the <ks>room</ks> with which he has to interact (<ks>fridge</ks>, <ks>dishwasher</ks>, <ks>pantry</ks>, <ks>table</ks>) and also it must be able to return on its <ks>RH</ks>. Therefore, to know where the elements and the <ks>RH</ks> are situated in the <ks>room</ks>, it's available a support, <m>it.unibo.planner20-1.0.jar</m>, which allows <k>rbr</k>, at its boot, to create a map of the <ks>room</ks> or to load an existing one.</dd>
	<br>
	<dd>To be able to map the <ks>room</ks> and to satisfy the requirement <i><em>avoid</em> the impact with obstacles</i>, it's possible to use data collected from a <tt>sensor</tt>, which can be represented by a <tt>sonar</tt> (in both virtual and real robot). In the library <m>it.unibo.qak21.basicrobot-1.0.jar</m>, provided by the customer, the <tt>sonar</tt> is already integrated and used by the <k>basicrobot</k>.</dd>
	<br>
	<dd>To manage the the <em>stop</em>/<em>reactivate</em> commands received by the <k>maitre</k>, during the execution of each <ks>task</ks>, it's possible to split the path, the <k>rbr</k> must execute, in a steps sequence. In this way, at the end of each step the <k>rbr</k> checks if it has received a <em>stop</em> command and in this case it saves its state and waits for the <em>reactivate</em> command, otherwise it carries out the next step.</dd>
	<br>
	<dd>During the execution of each <ks>task</ks>, the <k>rbr</k> must interact with all the resources by taking or bringing elements to or from them. Therefore, the state of these resources must be updated and the most indicated solution is for the <k>rbr</k> to do it.</dd>
	<br>
	<img src="./utils/img/ProblemAnalysis/RBRctx.png" alt="Context of RBR">
	<br>
	
	<dt>Maitre</dt>
	<dd>The software running on the <ks>maître's smartphone</ks> must provide an user interface to allow the user (<ks>Maître de Salle</ks>) to interact with the system. This software may be a native application (<tt>Android</tt> or <tt>IOS</tt>) or a <tt>web</tt> application running on a mobile browser; but, after a careful evaluation of the available means to design this software, it results more appropriate the use of a <tt>web</tt> application, as it appears to be a more versatile tool.</dd>
	<br>
	<dd>A problem could be represented by the sending of the <em>prepare</em> command. In fact, before sending this command, it's necessary to specify how much elements the <k>rbr</k> has to take from the resources (<ks>pantry</ks> and <ks>fridge</ks>) and bring to the <ks>table</ks>, being careful that the number of these elements is less or equal then the available number of elements. This can be done in different ways:
	<ol>
		<li><a name="sol1_cpv"></a>using, in the code, prefixed values for the number of elements in <em>prepare</em> command; but it's never a good practice;</li>
		<li><a name="sol2_fpv"></a>loadind from a <tt>prolog</tt> file, prefixed values for the number of elements in <em>prepare</em> command;</li>
		<li><a name="sol3_cbp"></a>making that the <ks>Maître de Salle</ks> can decide which and how many elements to insert in the <em>prepare</em> command.</li>
	</ol>
	Initially, in a first design phase, it's adopted the <a href="./Analysis.html#sol2_fpv">second solution</a>, which, in future, could be improved by integrating it with the <a href="./Analysis.html#sol2_cbp">third solution</a>, that seems to be the best, because it's predisposed to a possibile future change of the resources initial state.<dd>
	<br>
	<dd>A similar problem could be represented from <em>addFood</em> command. Here, before sending this command, the <ks>Maître de Salle</ks> must specify which element, through its <ks>food-code</ks>, the <k>rbr</k> must require to the <k>fridge</k> and, if possible, take and bring it to the <k>table</k>. As for the <em>prepare</em> command, this can be done loading from a <tt>prolog</tt> file a prefixed <ks>food-code</ks>; but, then, it could be improved by making possible for the <ks>Maître de Salle</ks> the choose of this element from a set of <ks>food-codes</ks>.<dd>
	<br>
	<dd>To make able the <ks>Maître de Salle</ks> to choose the elements for <em>prepare</em> and <em>addFood</em> commands, it could be useful to run a <em>consult</em> command to <k>fridge</k> and <k>pantry</k> at the start of the system automatically, so as to have a set of the updated resources state values, which limit the choose, by <ks>Maître de Salle</ks>, of the elements (that must be less or equal then the available number of elements).</dd>
	<br>
	<dd>With regard of the <em>clear</em> command related to the <ks>Clear the room</ks> task, the <k>rbr</k> has to know which and how much elements it has to take from the <k>table</k> and bring to the <k>dishwasher</k> and to the <k>fridge</k>. Similarly to the <em>prepare</em> and <em>addFood</em> command, to do this, it could be useful to run a <em>consult</em> command to the <k>table</k>. This can be done automatically by the <k>maitre</k> before sending the <em>clear</em> command to the <k>rbr</k> or by the <k>rbr</k> before executing the <ks>Clear the room</ks> task.</dd>
</dl>

<h3><a name="PrAnModel"></a>Model of System's Logical Architecture</h3>

Below it's shown a model, that is a representation of the system architecture obtained from the problem analysis using <tt>QActor</tt> meta-model. In particular, starting from the <a href="./Analysis.html#ReqAnModel">model</a> obtained from the requirements analysis, in this model there are represented the main entities of the system as <tt>actors</tt> (<k>maitre</k>, <k>rbr</k>, <k>fridge</k>, <k>pantry</k>, <k>table</k>, <k>dishwasher</k>) which runs on their own <tt>contexts</tt> (<k>ctxmaitre</k>, which includes also the non-smart resources <tt>actors</tt>, <k>ctxrbr</k>, <k>ctxfridge</k>).<br>
At each resource (smart and non-smart) it's associated a <a href="../ProblemAnalysisModel/resources/util/ActorCoapObserver.kt" target="_blank"><tt>CoAP observer</tt></a>.<br>
The initial state of each resource and the methods to update it are managed through <tt>prolog</tt> files (<a  href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/FridgeState.pl" target="_blank">FridgeState.pl</a>, <a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/PantryState.pl" target="_blank">PantryState.pl</a>, <a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/DishwasherState.pl" target="_blank">DishwasherState.pl</a>, <a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/TableState.pl" target="_blank">TableState.pl</a>).<br>
The elements and the <ks>food-code</ks> for the <em>prepare</em> and <em>addFood</em> commands are also managed by a <tt>prolog</tt> file (<a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/Prepare.pl" target="_blank">Prepare.pl</a>).<br>
Furthermore, the <em>clear</em> command is managed, <k>maitre</k> side, by sending a <em>consult</em> command to the <k>table</k> before sending the <em>clear</em> command to the <k>rbr</k>.
<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		<a href="../ProblemAnalysisModel/src/model.qak" target="_blank">ProblemAnalysisModel.qak</a><br>
		<pre><iframe class="qakProblem" src="../ProblemAnalysisModel/src/model.qak" title="ProblemAnalysisModel">Model of Problem Analysis</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ProblemAnalysis/ModelProblemAnalysisLegend.png" alt="Legend of the Logical Architecture System Model from Problem Analysis"><br>
		<img src="./utils/img/ProblemAnalysis/ModelFromProblemAnalysis.png" alt="Logical Architecture System Model from Problem Analysis">
	</td>
</tr>
</table>

<h3><a name="PrAnTestPlans"></a>Test Plans</h3>

Below it's reported a functional tests planning starting from the <a href="./Analysis.html#reqATP">requirements analysis test plans</a>:
<br><br>
<ul>
	<li>Tests of the position of the <ks>RBR</ks> that must be on its <ks>RH</ks> when system starts and at the end of each <ks>task</ks>;</li>
	<li>Tests of all the communications between entities;</li>
	<li>Tests of all the communications via <tt>CoAP</tt>;</li>
	<li>Tests of the states for each element (<ks>fridge</ks>, <ks>pantry</ks>, <ks>dishwasher</ks>, <ks>table</ks>) in the <ks>room</ks> in every moment of the service (start, end, end <ks>task</ks>, <em>consult</em> command);</li>
	<li>Tests of the path carried out by the <ks>RBR</ks> that must be the one expected to execute the <ks>task</ks> required by the <ks>Maître de Salle</ks>;</li>
	<li>Tests of the mutual exclusion of <ks>tasks</ks> and of their order of execution;</li>
	<li>Tests of the state of the <ks>RBR</ks> to verify that it is stopped after receiving <em>stop</em> command and to verify that it resumes <ks>task</ks> execution after receiving the <em>reactivate</em> command;</li>
	<li>Tests of the <em>stop</em> and <em>reactivate</em> commands that can be used by <ks>Maître de salle</ks> only when there is a running <ks>task</ks>;</li>
	<li>Test of the capability of the <ks>RBR</ks> to <em>avoid</em> all the possible obstacles.</li>
</ul>

<h4>Tests</h4>

Below there are exposed some tests made for the <a href="./Analysis.html#PrAnModel">model</a> achieved from the problem analysis:
<dl>
	<dt><a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/test/it/unibo/test/PantryTest.kt" target="_blank">PantryTest.kt</a></dt>
	<dd>Tests about removing of dishes from the <k>pantry</k>, useful for <ks>Prepare the room</ks> <ks>task</ks>:<ol>
		<li><em>RemoveDishPantryTest</em>: after a remove operation, changing the <k>pantry</k> state via <tt>CoAP</tt>, it's verified that the operation was successful;</li>
		<li><em>RemoveDishPantryFailTest</em>: after a remove operation of a not existing element, changing the <k>pantry</k> state via <tt>CoAP</tt>, it's verified that the operation fails;</li>
		<li><em>RemoveDishPantryFailQuantityTest</em>: after a remove operation of an existing element but not available for the required quantity, changing the <k>pantry</k> state via <tt>CoAP</tt>, it's verified that the operation fails.</li>
	</ol></dd>
	<br>
	<dt><a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/test/it/unibo/test/DishwasherTest.kt" target="_blank">DishwasherTest.kt</a></dt>
	<dd>Tests about adding of dishes to the <k>dishwasher</k>, useful for <ks>Clear the room</ks> <ks>task</ks>:<ol>
		<li><em>AddDishdishwasherTest</em>: after an add operation, changing the <k>dishwasher</k> state via <tt>CoAP</tt>, it's verified that the operation was successful.</li>
	</ol></dd>
	<br>
	<dt><a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/test/it/unibo/test/FridgeTest.kt" target="_blank">FridgeTest.kt</a></dt>
	<dd>Tests about removing and adding of foods from and to the <k>fridge</k>, useful for <ks>Prepare the room</ks>, <ks>Add food</ks> and <ks>Clear the room</ks> <ks>tasks</ks>:<ol>
		<li><em>RemoveFoodFridgeTest</em>: after a remove operation, changing the <k>fridge</k> state via <tt>CoAP</tt>, it's verified that the operation was successful;</li>
		<li><em>RemoveFoodFridgeFailTest</em>: after a remove operation of a not existing element, changing the <k>fridge</k> state via <tt>CoAP</tt>, it's verified that the operation fails;</li>
		<li><em>RemoveFoodFridgeFailQuantityTest</em>: after a remove operation of an existing element but not available for the required quantity, changing the <k>fridge</k> state via <tt>CoAP</tt>, it's verified that the operation fails;</li>
		<li><em>AddFoodFridgeTest</em>: after an add operation, changing the <k>fridge</k> state via <tt>CoAP</tt>, it's verified that the operation was successful.</li>
	</ol></dd>
	<br>
	<dt><a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/ProblemAnalysisModel/test/it/unibo/test/TableTest.kt" target="_blank">TableTest.kt</a></dt>
	<dd>Tests about removing and adding of dishes and foods from and to the <k>table</k>, useful for <ks>Prepare the room</ks>, <ks>Add food</ks> and <ks>Clear the room</ks> <ks>tasks</ks>:<ol>
		<li><em>AddRemoveDishTableTest</em>: after an add and then a remove operation of dishes element, changing the <k>table</k> state via <tt>CoAP</tt>, it's verified that the remove operation was successful;</li>
		<li><em>RemoveDishTableFailTest</em>: after a remove operation of a not existing dishes element, changing the <k>table</k> state via <tt>CoAP</tt>, it's verified that the operation fails;</li>
		<li><em>RemoveDishTableFailQuantityTest</em>: after a remove operation of an existing dishes element but not available for the required quantity, changing the <k>table</k> state via <tt>CoAP</tt>, it's verified that the operation fails;</li>
		<li><em>AddFoodTableTest</em>: after an add operation of a food element, changing the <k>table</k> state via <tt>CoAP</tt>, it's verified that the operation was successful;</li>
		<li><em>RemoveFoodTableTest</em>: after a remove operation of a food element, changing the <k>table</k> state via <tt>CoAP</tt>, it's verified that the operation was successful;</li>
		<li><em>RemoveFoodTableFailTest</em>: after a remove operation of a not existing food element, changing the <k>table</k> state via <tt>CoAP</tt>, it's verified that the operation fails;</li>
		<li><em>RemoveFoodTableFailQuantityTest</em>: after a remove operation of an existing food element but not available for the required quantity, changing the <k>table</k> state via <tt>CoAP</tt>, it's verified that the operation fails.</li>
	</ol></dd>
</dl>
<br>
These tests are executed on a single <tt>context</tt> (<k>ctxsystem</k>) and to execute them, it's necessary to comment the <k>maitre</k>, because it is a <tt>mock client</tt> and it could interfere with tests.

<h3>SCRUM Context</h3>

<h4>Product Backlog</h4>

A first Product Backlog could have these elements:
<br><br>
<ol>
	<li>Resources representation</li>
	<li>Resources state</li>
	<li><tt>CoAP</tt> integration</li>
	<li><em>Consult</em></li>
	<li><ks>Prepare the room</ks> <ks>task</ks></li>
	<li><ks>Add Food</ks> <ks>task</ks></li>
	<li><ks>Clear the room</ks> <ks>task</ks></li>
	<li>Planning</li>
	<li>Integration of <k>basicrobot</k> with the <k>rbr</k></li>
	<li><tt>Sonar</tt></li>
	<li>Mapping</li>
	<li><em>Stop</em>/<em>Reactivate</em></li>
	<li><tt>GUI</tt> <ks>maître's smartphone</ks> software</li>
	<li>Deployment</li>
	<li>Maintenance</li>
</ol>

<h4>First SPRINT Sequence</h4>

<dl>
<dt>SPRINT 0</dt>
<dd>The problem analysis already solves some problems; so the resulting <a href="./Analysis.html#PrAnModel">model</a> could represent the result of a first SPRINT. In particular, the elements DONE of this SPRINT are:
<ol>
	<li>Resources representation: an <tt>actor</tt> for each non-smart resource</li>
	<li>Resources state: a <tt>prolog</tt> file for each resource <tt>actor</tt></li>
	<li><tt>CoAP observer</tt>: for <tt>CoAP</tt> communications from resources <tt>actors</tt> (smart and non-smart) to listening <tt>actors</tt></li>
	<li><em>Consult</em>: communications between <tt>actors</tt> and get methods in <tt>prolog</tt> files of resources state</li>
	<li><ks>Prepare the room</ks> <ks>task</ks>: communications between <tt>actors</tt> and add and remove methods in <tt>prolog</tt> files of resources state</li>
	<li><ks>Add Food</ks> <ks>task</ks>: communications between <tt>actors</tt> and check for specific food and add and remove methods in <tt>prolog</tt> files of resources state</li>
	<li><ks>Clear the room</ks> <ks>task</ks>: communications between <tt>actors</tt> and add and remove methods in <tt>prolog</tt> files of resources state</li>
	<li>Tests</li>
</ol></dd>
</dl>
<br>
A possibile set of next SPRINT could be:
<dl>
	<dt>SPRINT 1</dt>
	<dd><ol>
		<li><ks>Table</ks> state: consumption of food</li>
		<li>Planning: insert an initial map representation and use of <tt>Planner</tt></li>
		<li>Integration of <k>basicrobot</k> with the <k>rbr</k></li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt></li>
		<li><ks>Add Food</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt></li>
		<li><ks>Clear the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt></li>
		<li>Tests</li>
	</ol></dd>
	<br>
	<dt>SPRINT 2</dt>
	<dd><ol>
		<li><tt>Sonar</tt></li>
		<li>Mapping</li>
		<li><i><em>Avoid</em> the impact with obstacles</i> requirement</li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> <em>avoiding</em> the obstacles</li>
		<li><ks>Add Food</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> <em>avoiding</em> the obstacles</li>
		<li><ks>Clear the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> <em>avoiding</em> the obstacles</li>
		<li>Tests</li>
	</ol></dd>
	<br>
	<dt>SPRINT 3</dt>
	<dd><ol>
		<li><em>Stop</em>/<em>Reactivate</em></li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> receiving <em>stop</em> and then <em>reactivate</em> commands</li>
		<li><ks>Add Food</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> receiving <em>stop</em> and then <em>reactivate</em> commands</li>
		<li><ks>Clear the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> receiving <em>stop</em> and then <em>reactivate</em> commands</li>
		<li>Tests</li>
	</ol></dd>
	<br>
	<dt>SPRINT 4</dt>
	<dd><ol>
		<li><tt>GUI</tt> <ks>maître's smartphone</ks> software</li>
		<li>Tests</li>
	</ol></dd>
	<br>
	<dt>SPRINT 5</dt>
	<dd><ol>
		<li>Deploy on <tt>Raspberry</tt></li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Add Food</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Clear the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li>Tests</li>
	</ol></dd>
</dl>

<h2>Project</h2>

<h3>SPRINT 1</h3>

The project part related to this Sprint is available <a href="https://github.com/bluffgnuff/RomeoRussoISS2021/tree/master/Sprint_1" target="_blank">here</a> and it's documented in <a href="../Sprint_1/SPRINT_1/userDocs/SPRINT_1.html" target="_blank">SPRINT_1.html</a>.

<h4>Goal</h4>

The Goal for this Sprint are:
<div class="remark">
<ol>
	<li>Consumption of food on the <ks>table</ks></li>
	<li>Planning: using the <tt>Planner</tt> loading an initial map representation</li>
	<li>Integration of <k>basicrobot</k> with the <k>rbr</k></li>
	<li><ks>Prepare the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt></li>
	<li><ks>Add Food</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt></li>
	<li><ks>Clear the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt></li>
</ol>
</div>

<h4>Result</h4>

The resulting model of system's logical architecture for this Sprint is:
<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		<a href="../Sprint_1/SPRINT_1/src/model.qak" target="_blank">Sprint_1.qak</a><br>
		<pre><iframe class="qakSprint" src="../Sprint_1/SPRINT_1/src/model.qak" title="ModelSprint_1">Model of Sprint 1</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="../Sprint_1/SPRINT_1/userDocs/utils/img/ModelSprint1_Legend.png" alt="Legend of the Logical Architecture System Model from Sprint 1"><br>
		<img src="../Sprint_1/SPRINT_1/userDocs/utils/img/ModelSprint_1.png" alt="Logical Architecture System Model from Sprint 1">
	</td>
</tr>
</table>

<div hidden="hidden">
<h3>SPRINT 2</h3>

The project part related to this Sprint is available <a href="https://github.com/bluffgnuff/RomeoRussoISS2021/tree/master/SPRINT_2" target="_blank">here</a> and it's documented in <a href="../SPRINT_2/userDocs/SPRINT_2.html" target="_blank">SPRINT_2.html</a>.

<h4>Goal</h4>

The Goal for this Sprint are:
<div class="remark">
<ol>
	<li></li>
</ol>
</div>

<h4>Result</h4>

The resulting model of system's logical architecture for this Sprint is:
<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		<a href="../SPRINT_2/src/model.qak" target="_blank">Sprint_2.qak</a><br>
		<pre><iframe class="qakSprint" src="../SPRINT_2/src/model.qak" title="ModelSprint_2">Model of Sprint 2</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="../SPRINT_2/userDocs/utils/img/ModelSprint2_Legend.png" alt="Legend of the Logical Architecture System Model from Sprint 2"><br>
		<img src="../SPRINT_2/userDocs/utils/img/ModelSprint_2.png" alt="Logical Architecture System Model from Sprint 2">
	</td>
</tr>
</table>
</div>
<h2>Deployment</h2>

<h2>Maintenance</h2>

</div>
<br><br>
<div class="endpage">
By Romeo Stefano (stefano.romeo@studio.unibo.it) and Russo Maria (maria.russo10@studio.unibo.it)<br>
<img class="photo" src="./utils/img/StefanoRomeo.png" alt="Stefano Romeo image">
<img class="photo" src="./utils/img/MariaRusso.png" alt="Maria Russo image">
</div>

<div hidden="hidden">elementi utili:
Table:
<table>
<tr>
	<td></td>
	<td></td>
</tr>
</table>
Sorted List:
<ol>
<li></li>
<li></li>
</ol>
Unordered List:
<ul>
<li></li>
<li></li>
</ul>
Definition list:
<dl>
<dt></dt>
<dd></dd>
</dl>
Link:
<a href="" target="_blank"></a>
Link in pagina:
<a name="link"></a> + <a href="./Analysis.html#link">text</a>
IFrame:
<iframe src="./src" title="title">"Link"/Cosa c'è nel frame</iframe>
<br>Image:
<img src="./utils/img/Nome.png" alt="description">
</div>

</body>
</html>
