<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<link rel="stylesheet" type="text/css" href="./utils/style.css">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<base href=".">
<title>RomeoRussoStandingBuffetService</title>
</head>

<body>

<div id="top">
<h1>STANDING BUFFET SERVICE | Ingengeria dei Sistemi Software</h1>
</div>

<div class="body">

<h2>Introduction</h2>

Keeping in mind the motto: <bc>"there is no code without a project, no project without problem analysis and no problem without requirements"</bc>, this document presents a possible solution to the requirements provided by the customer, achieved with a top-down approach in three main phase: requirements analysis, problem analysis and a design phase.

<h2>Requirements</h2>

<div class="remark">
Below it's shown the <a href="./utils/tf/TemaFinaleBo19.html" target="_blank">requirements text</a> provided by the customer.<br>
<br>
<iframe src="./utils/tf/TemaFinaleBo19.html" title="Requirements text"><a href="./utils/tf/TemaFinaleBo19.html" target="_blank">Requirements Text Link</a></iframe>
</div>

<h2>Requirement analysis</h2>

<h3>Glossary</h3>

By the interaction with the customer, here it's exposed an essential glossary about the meaning of the names and of the verbs included in the <a href="./utils/tf/TemaFinaleBo19.html" target="_blank">requirements text</a> given by the customer.
<br><br>
<table>
<tr>
	<td class="title"><ks>room</ks></td>
	<td>It's an environment equipped with a set of smart and non-smart resources and in which the interactions between these elements happen. These resources are: a <ks>pantry</ks>, a <ks>dishwasher</ks> and a <ks>fridge</ks>, that are all embedded into the wall of the room; a <ks>table</ks>, that is placed in the center of the room; an <ks>RBR</ks>. When system starts no people is in it, besides the <ks>Maître de Salle</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>Maître de Salle</ks></td>
	<td>Person who manages the <ks>room</ks> and its elements, using the <ks>maître's smartphone</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>maître's smartphone</ks></td>
	<td>Smartphone application or a user-GUI in a browser used by <ks>Maître de Salle</ks> to interact with smart resources in the <ks>room</ks> (<ks>fridge</ks> and <ks>RBR</ks>).</td>
</tr>
<tr>
	<td class="title"><ks>fridge</ks></td>
	<td>It's a smart device, having knowledge base on his storage, and an "Internet Thing". It's embedded into the wall of the <ks>room</ks> and it's filled with a proper set of items when system starts. It must be able to comunicate, via CoAP, with <ks>maître's smartphone</ks> and <ks>RBR</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>pantry</ks></td>
	<td>It's a non-smart resource embedded into the wall of the <ks>room</ks> and it's filled with a proper set of items when system starts.</td>
</tr>
<tr>
	<td class="title"><ks>dishwasher</ks></td>
	<td>It's a non-smart resource embedded into the wall of the <ks>room</ks> and it's empty when system starts.</td>
</tr>
<tr>
	<td class="title"><ks>table</ks></td>
	<td>It's a non-smart resource put in the center of the <ks>room</ks> and it's empty when system starts.</td>
</tr>
<tr>
	<td class="title"><ks>RBR - <i>Room Butler Robot</i></ks></td>
	<td>It's a <ks>DDR</ks> able to work as a Room Butler: it must be able to comunicate with <ks>maître's smartphone</ks> and <ks>fridge</ks> and to walk around the <ks>room</ks> to execute the <ks>task</ks>, avoiding the fixed and mobile obstacles. When system starts and after it completed a <ks>task</ks>, it must wait new commands in the <ks>RH</ks> position.</td>
</tr>
<tr>
	<td class="title"><ks>DDR - <i>Differential Drive Robot</i></ks></td>
	<td>The customer provided all the documentation about this topic: the documentation about the basicRobot (at <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html" target="_blank">basicrobot2021.html</a>), that can be implemented as a virtual robot (at <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html" target="_blank">VirtualRobot2021.html</a>) or as a real robot, that can be an mbot (at <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/Mbot2020.html" target="_blank">MBot2020.html</a>) or a nano robot (at <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/LabNanoRobot.html" target="_blank">LabNanoRobot.html</a>).</td>
</tr>
<tr>
	<td class="title"><ks>RH - <i>Robot Home</i></ks></td>
	<td>It's the position in the <ks>room</ks> where the <ks>RBR</ks> boots up and where he comes back after every <ks>task</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>task</ks></td>
	<td>it's a task that the <ks>RBR</ks> must execute when required by <ks>Maître de salle</ks> via <ks>maître's smartphone</ks>. There are three possible tasks, that are mutually exclusive and that must be executed in this order: <ks>Prepare the room</ks>, <ks>Add food</ks> and finally <ks>Clear the room</ks>.</td>
</tr>
<tr>
	<td class="title"><ks>Prepare the room</ks></td>
	<td>This <ks>task</ks> consists in putting on the <ks>table</ks> dishes taken from the <ks>pantry</ks> and food taken from the <ks>fridge</ks>. The set of items to put on the <ks>table</ks> is fixed and it's properly described somewhere.</td>
</tr>
<tr>
	<td class="title"><ks>Add food</ks></td>
	<td>This <ks>task</ks> consists in putting on the <ks>table</ks> some specific food (defined by a <ks>food-code</ks>) taken from the <ks>fridge</ks> if it exists.</td>
</tr>
<tr>
	<td class="title"><ks>food-code</ks></td>
	<td>Univoque code associated to a specific food.</td>
</tr>
<tr>
	<td class="title"><ks>Clear the room</ks></td>
	<td>This <ks>task</ks> consists in putting in the <ks>fridge</ks> and in the <ks>dishwasher</ks> respectively non-consumed food and dishes taken from the <ks>table</ks>.</td>
</tr>
</table>

<h3>Requirements analysis</h3>

Once we have understood the main concepts set by the <a href="./utils/tf/TemaFinaleBo19.html" target="_blank">requirements text</a> given by the customer, it's now possible to analyze them.
<br><br>
<table>
<tr>
	<td>The software system is a distribuited system composed by three main entities:
	<ul>
		<li><ks>RBR</ks>, running on its own <kc>robotNode</kc>;</li>
		<li><ks>maître's smartphone</ks>, running on a <kc>maitreNode</kc>;</li>
		<li><ks>fridge</ks>, running on a <kc>fridgeNode</kc>.</li>
	</ul>
	</td>
	<td class="image"><img src="./utils/img/threeEntities.png" alt="Three entities"></td>
</tr>
<tr>
	<td>The software running on <kc>maitreNode</kc> must allow <ks>Maître de Salle</ks> to:
	<ul>
		<li>send the commands to <ks>RBR</ks> to execute <ks>tasks</ks> or to stop and reactivate them (only if there are already activated <ks>tasks</ks>);</li>
		<li>known and to show the objects related to each resources, smart (<ks>fridge</ks>) and non-smart(<ks>pantry</ks>, <ks>dishwasher</ks>, <ks>table</ks>), so it must be able to comunicate with <ks>fridge</ks> too.</li>
	</ul>
	</td>
	<td class="image" rowspan="3"><img src="./utils/img/entitiesRel.png" alt="Relationships between entities"></td>
</tr>
<tr>
	<td>The software running on <kc>robotNode</kc> must be able to:
	<ul>
		<li>execute the <ks>task</ks> associated to command received by the <ks>maître's smartphone</ks>;</li>
		<li>stop/reactivate a running <ks>task</ks> when it's required by the <ks>maître's smartphone</ks>;</li>
		<li>ask <ks>fridge</ks> if it contains a specific food defined by a <ks>food-code</ks> and to receive the answer;</li>
		<li>send a warning to the <ks>maître's smartphone</ks> when the <ks>fridge</ks> doesn't contain the food required;</li>
		<li>return to his <ks>RH</ks> at the end of every <ks>task</ks>;</li>
		<li>avoid the impact with obstacles.</li>
	</ul>
	</td>
</tr>
<tr>
	<td>The software running on <kc>fridgeNode</kc> must be able to:
		<ul>
		<li>answer to the <ks>maître's smartphone</ks>, via CoAP (so it must know the destination URI), with his content when it's required;</li>
		<li>answer to the <ks>RBR</ks>, via CoAP (so it must know the destination URI), when it asks if it contains a specific food defined by a <ks>food-code</ks>.</li>
		</ul>
	</td>
</tr>
</table>

<h3>A first set of functional Test Plans</h3>

<h4>Scenario</h4>

Here, it's illustrated a possible scenario of the system.
<br><br>
<table>
<tr>
<th>Steps in the scenario</th>
<th>Simplified representation of each step</th>
</tr>
<tr>
	<td><ol><li>The <ks>room</ks> is empty, beside the <ks>Maître de Salle</ks>. The <ks>RBR</ks> is on its <ks>RH</ks>. The <ks>fridge</ks> and the <ks>pantry</ks> are embedded with a proper set of items; while the <ks>dishwasher</ks> and the <ks>table</ks> are empty.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/InitialScenario.png" alt="Initial scenario"></td>
</tr>
<tr>
	<td><ol start="2"><li>The <ks>Maître de Salle</ks> sends the <em>prepare</em> command (for the <ks>task</ks> <ks>Prepare the room</ks>) to the <ks>RBR</ks> and waits. The <ks>RBR</ks> executes the <ks>task</ks> related to the command and at the end he returns to its <ks>RH</ks>.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ScenarioPrepare.png" alt="Scenario 'Prepare the room'"></td>
</tr>
<tr>
	<td><ol start="3"><li>The party starts and the <ks>room</ks> is opened to people: so now there are other obstacoles in the <ks>room</ks>. The <ks>Maître de Salle</ks> can send at any time to <ks>RBR</ks> the <em>addFood (food-code)</em> command (for the <ks>task</ks> <ks>Add food</ks>). The <ks>RBR</ks> asks <ks>fridge</ks> if it has the food specified by <ks>food-code</ks> and the <ks>fridge</ks> answers to <ks>RBR</ks>, via CoAP, with <em>answer</em> command. If the <ks>fridge</ks> doesn't contain that food, then the <ks>RBR</ks> sends a warning to the <ks>Maître de Salle</ks>; otherwise the <ks>RBR</ks> executes the <ks>task</ks> and then he returns to its <ks>RH</ks>.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ScenarioAddFood.png" alt="Scenario 'Add food'"></td>
</tr>
<tr>
	<td><ol start="4"><li>At the end of the party the <ks>room</ks> is empty again, beside the <ks>Maître de Salle</ks>. The <ks>Maître de Salle</ks> sends to <ks>RBR</ks> the <em>clear</em> command (for the <ks>task</ks> <ks>Clear the room</ks>) and waits. The <ks>RBR</ks> executes the <ks>task</ks> and then he returns to its <ks>RH</ks>.</li></ol></td>
	<td class="imageScenario"><img src="./utils/img/ScenarioClear.png" alt="Scenario 'Clear the room'"></td>
</tr>
<tr>
	<td colspan="2">At every time of the service:
	<ul>
		<li>The <ks>Maître de Salle</ks> can use <em>consult</em> command to know the state of each element in the <ks>room</ks> (<ks>fridge</ks>, <ks>pantry</ks>, <ks>dishwasher</ks>, <ks>table</ks>). In this case, the <ks>fridge</ks> answers via CoAP, using the <em>expose</em> command, to show its content.</li>
		<li>The <ks>Maître de Salle</ks> can use the <em>stop</em> or <em>reactivate</em> command to stop or restart an already activated <ks>task</ks>, otherwise these commands have no effect.</li>
		<li>The <ks>RBR</ks> must <em>avoid</em> the obstacles.</li>
	</ul>
	</td>
</tr>
</table>

<h4>Test Plans</h4>

It's necessary to make some test plans that must be verified for the correct working of the final system, according to the requirements provided by the customer.
<br>Below it's reported a first planning of tests:
<br><br>
<ul>
<li>Tests of the position of the <ks>RBR</ks> that must be on its <ks>RH</ks> when system starts and at the end of each <ks>task</ks>;</li>
<li>Tests of the states for each element (<ks>fridge</ks>, <ks>pantry</ks>, <ks>dishwasher</ks>, <ks>table</ks>) in the <ks>room</ks> in every moment of the service (start, end, end <ks>task</ks>, <em>consult</em> command);</li>
<li>Tests of all the communications between entities;</li>
<li>Tests of the path carried out by the <ks>RBR</ks> that must be the one expected to execute the <ks>task</ks> required by the <ks>Maître de Salle</ks>;</li>
<li>Tests of the mutual exclusion of <ks>tasks</ks> and of their order of execution;</li>
<li>Tests of the state of the <ks>RBR</ks> to verify that it is stopped after receiving <em>stop</em> command and to verify that it resumes <ks>task</ks> execution after receiving the <em>reactivate</em> command;</li>
<li>Tests of the <em>stop</em> and <em>reactivate</em> commands that can be used by <ks>Maître de salle</ks> only when there is a running <ks>task</ks>;</li>
<li>Test of the capability of the <ks>RBR</ks> to <em>avoid</em> all the possible obstacles.</li>
</ul>

<h3>A first model of the system architecture</h3>

From the requirements analysis, it's possible to obtain a first model, that is an univoque initial representation of the system architecture, using a meta-model written in a machine-understandable language, like QActor, that describes the main interactions and behaviors between the main system components. In particular, the three main entities are represented by three actors (QActors, that behave as Finite State Machines and work as a CoAP observable resources) and the nodes where they run are represented by contexts.
<br><br>
Making this, there were been found some problems, that will be addressed and solved next in the problem analysis:
<ul>
	<li>the stop/reactivate feature is just described as a dispatcher but is still not working cause none state reads that message; </li>
	<li>the consult feature is still not completed cause it's necessary to manage the state information of smart and non smart elements, but in this representation it's handled only the fridge state information.</li>
</ul>
Furthermore, the maitre is described here as a mock client, because it's early, in the requirements analysis, to represent his full proactive behavior that depend from a GUI.
<br><br>
<table>
<tr>
<th>Machine understandable architecture model</th>
<th>A possible graphic representation</th>
</tr>
<tr>
<td class="text" rowspan="3"><a href="./ReqAnalysisModel.qak" target="_blank">ReqAnalysisModel.qak</a><br><pre><iframe class="qak" src="./ReqAnalysisModel.qak" title="ReqAnalysisModel">Model of Requirements Analysis</iframe></pre></td>
<td class="imageSchema">
<img src="./utils/img/FirstModelFromReqAnalysis.png" alt="Representations of the system from Requirements Analysis"><br>
</td>
</tr>
<tr>
<th>Moore State Machine Diagram</th>
</tr>
<tr>
<td class="imageSchema">
<img src="./utils/img/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
<img src="./utils/img/QActorMaitre.png" alt="Representation of the behavior of QActor maitre, modeled as a Moore state machine"><br>
<img src="./utils/img/QActorRBR.png" alt="Representation of the behavior of QActor rbr, modeled as a Moore state machine"><br>
<img src="./utils/img/QActorFridge.png" alt="Representation of the behavior of QActor fridge, modeled as a Moore state machine">
</td>
</tr>
</table>

<h2>Problem analysis</h2>

<dl>
<dt>What To Do:</dt>
<dd><ol>
<li>Identify the main (technical) problems involved by the requirements<br>
		+	the most appropriate (software) technologies (the best tools/libraries/supports etc.) to adopt that are necessary and/or useful for building the system<br>
		+	evaluate the abstraction gap and give a quantitative measure of the effort/resources necessary to build the system and clarify the constraints (human, technical, economical, etc.) related to both the software product to build and the software production process</li>
<li>Define (a model of) the logical architecture of the system</li>
<li>Refine the set of functional TestPlan</li>
<li>In the context of SCRUM:<ul>
	<li>define a (first) product backlog</li>
	<li>a possibile set/sequence of SPRINT</li>
</ul></li>
</ol></dd>
</dl>

<h3>Identification of the problems and the corresponding solutions</h3>

Starting from the requirements analysis, it's now necessary to found the main problems and abstraction gap involved by the requirements and to solve them, establishing the most appropriate technologies necessary for building the system.
<br><br>
<ol>
<li><dl>
	<dt>General System</dt>
	<dd>In the requirements analysis, there were been identified three main entities that run on different nodes, therefore the system is distribuited. To model it, it's available the QAk-infrastracture, provided by the "it.unibo.qakactor-2.4.jar" library. This framework provides a built-in message-driven tecnology to support the communications between different actors running on different contexts. In this way, it's possible to design the main components of the system using QActor meta-model.</dd><br>
	<dd>To support the distribuited communications, it's possible to use the TCP, MQTT and/or CoAP protocols; the last one, by requirements, must be used by the fridge to communicate with the other two main components. In particular, MQTT is a IoT optimized messagging protocol which allows to implement a publish/subscribe interaction; while CoAP is a protocol for point-to-point comunications among different nodes on the same network. CoAP supports also the "observe mechanism" where the node state is seen as a resource (CoAP) observed by other CoAP clients.</dd><br>
	<dd>In the room there are non-smart resources, whose states should be managed by the software system. This could be done in different ways, listed below.<br><br>
	<table>
	<tr>
		<td><ol><li>Using a resource manager actor (RM) which manages the state of each non-smart resource. It receives the consult command from maitre and answers it exposing the state of each non-smart resource. Moreover, when the rbr executes the tasks, it interacts with the resource manager to change the state of each non-smart resource.
		<dl>
			<dt>Pro:</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li>easy for maitre to obtain the state of each resource, sending consult command to RM and fridge.</li>
			</ul></dd>
			<dt>Cons:</dt>
			<dd><ul>
				<li>The RM has to manage the state for every non-smart resource and this can result a concectually intricate operation when it must update a resource state at request of RBR.</li>
			</ul></dd>
		</dl>
		</li></ul></td>
		<td class="imageScenario"><img src="./utils/img/ResourcesStatusManagement_type1_model.png" alt="ResourcesStatusManagement_type1_model"></td>
	</tr>
	<tr>
		<td><ol start="2"><li>Using a resource manager which manages the state of each resource (smart and non-smart). It works as an intermediary between the maitre (which sends it the consult command to know the state of each resource) or the rbr (which interacts with it to change the state of each resource, during the execution of each task) and the other resources. In this way, the resource manager will know the states of non-smart resources and it will communicate with fridge to know its state.
		<dl>
			<dt>Pro:</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li>easy for maitre to obtain the state of each resource, only sending consult command to RM;</li>
				<li>RM is the only component that manages the resources and this brings to a cleaner architecture.</li>
			</ul></dd>
			<dt>Cons:</dt>
			<dd><ul>
				<li>The RM has to manage the state for every non-smart resource and this can result a concectually intricate operation when it must update a resource state at request of RBR;</li>
				<li>When RBR wants to change the state of the fridge there is one more step: the RBR must communicate with RM, which communicates to fridge the desired change.</li>
			</ul></dd>
		</dl>
		</li></ul></td>
		<td class="imageScenario"><img src="./utils/img/ResourcesStatusManagement_type2_model.png" alt="ResourcesStatusManagement_type2_model"></td>
	</tr>
	<tr>
		<td><ol start="3"><li>Managing the state of each non-smart resource using dedicated actors. In this way, the maitre, to know the state of each resource (smart and non-smart) sends to each actor the consult command. At the same way, when the rbr executes the tasks, it interacts with each actor to change the state of each resource.
		<dl>
			<dt>PRO</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li>RBR can communicate directly with the resource actor of which it wants to change the state.</li>
			</ul></dd>
			<dt>CONS</dt>
			<dd><ul>
				<li>because of the simplicity of non-smart resources, their representation through actors could result a computational resources waste;</li>
				<li>the maitre has to send a consult command for each resource actor and to wait for each reply.</li>
			</ul></dd>
		</dl>
		</li></ul></td>
		<td class="imageScenario"><img src="./utils/img/ResourcesStatusManagement_type3_model.png" alt="ResourcesStatusManagement_type3_model"></td>
	</tr>
	<tr>
		<td><ol start="4"><li>Managing the state of each non-smart resource using dedicated actors and using a resource manager which manages the state of each resource (smart and non-smart). It works as an intermediary between the maitre (which sends it the consult command to know the state of each resource) or the rbr (which interacts with it to change the state of each resource, during the execution of each task) and the other resources actors. In this way, the resource manager will communicate with fridge and the other non-smart resource actors to know their states.
		<dl>
			<dt>PRO</dt>
			<dd><ul>
				<li>easy to implement;</li>
				<li>the maitre delegates the RM for the manage of all the resources;</li>
				<li>the rbr delegates the RM for the state change of each resource.</li>
			</ul></dd>
			<dt>CONS</dt>
			<dd><ul>
				<li>because of the simplicity of non-smart resources, their representation through actors could result a computational resources waste;</li>
				<li>the RM has to send a consult command for each resource actor and to wait for each reply; then it must communicate the result to maitre;</li>
				<li>the RM must communicate with each resource actor when RBR requires for a state change;</li>
				<li>the RM works only as an intermediary from maitre or RBR and resource actors. It does the work of maitre and RBR adding a step; so it results not useful.</li>
			</ul></dd>
		</dl>
		</li></ul></td>
		<td class="imageScenario"><img src="./utils/img/ResourcesStatusManagement_type4_model.png" alt="ResourcesStatusManagement_type4_model"></td>
	</tr>
	<tr>
	<td><ol start="5"><li>Managing the state of each non-smart resource using dedicated actors and using a resource manager which manages the state of each resource (smart and non-smart). At system start, there is a registration protocol where each resource try to subscribe it-self to RM; so to make the system more dynamic and ready at future resource add. The RM works as an intermediary between the maitre (which sends it the consult command to know the state of each resource) or the rbr (which interacts with it to change the state of each resource, during the execution of each task) and the other resources actors. In this way, the resource manager will communicate with fridge and the other non-smart resource actors to know their states.
	<dl>
		<dt>PRO</dt>
		<dd><ul>
				<li>easy to implement;</li>
				<li>the maitre delegates the RM for the manage of all the resources;</li>
				<li>the rbr delegates the RM for the state change of each resource;</li>
				<li>the presence of a registration protocol makes the system more dynamic and ready at future resource add.</li>
		</ul></dd>
		<dt>CONS</dt>
			<dd><ul>
				<li>because of the simplicity of non-smart resources, their representation through actors could result a computational resources waste;</li>
				<li>the RM has to send a consult command for each resource actor and to wait for each reply; then it must communicate the result to maitre;</li>
				<li>the RM must communicate with each resource actor when RBR requires for a state change.</li>
			</ul></dd>
	</dl>
	</li></ul></td>
	<td class="imageScenario"><img src="./utils/img/ResourcesStatusManagement_type5_model.png" alt="ResourcesStatusManagement_type5_model"></td>
	</tr>
	</table>
	SOLUZIONE SCELTA!
	</dd><br>
	<dd>Futhermore, it's necessary a initialization procedure which loads the initial state for each resource (smart and non-smart) with its own elements set; (<-abstraction gap? -> solution:) this could be done loading the informations from a file, a DB and/or providing the maitre with a configuration tool.<br>
	(dobbiamo fare una scelta, indicando i motivi! Possiamo dire che questa scelta può essere definita durante la progettazione)</dd>
</dl></li>
<li><dl>
	<dt>RBR</dt>
	<dd>To allow RBR to move, the customer provides a library "it.unibo.qak21.basicRobot-1.0.jar". In particular, this framework provides the basicRobot (link?) and its possible implementations: virtual robot (link?), on its own WEnv (Web Environment), or real robot, that can be mbot (link?) or nano robot (link?).</dd>
	<dd>To execute the tasks, the RBR must be able to reach every element in the room with which he has to interact (fridge, dishwasher, pantry, table) and also it must be able to return on its RH. Therefore, to know where the elements and the RH are situated in the room (<- abstraction gap? -> solution:), it's available a support, IssActorKotlinRobotSupport-2.0.jar, which allows RBR, at its boot, to create a map of the room or to load an existing one.</dd>
	<dd>To be able to map the room and to satisfy the requirement "avoid the impact with obstacles", it's possible to use data collected from a sensor, which communicates through events with the RBR. This sensor can be rapresented, in the software system, by a sonar (in both virtual and real robot), whose library "it.unibo.qak21.basicrobot-1.0.jar" is provided by the customer.</dd>

	<dd>The RBR it's both a proactive, because (perchè è proattivo?), and a reactive element, because it reacts to the commands received from maitre and to events received from sonar to avoid the impact with obstacles. (riceve ed esegue i comandi, reagisce agli eventi (prodotti dall'attore sonar) per soddisfare il requisito 'avoid the impact with the mobile obstacles')</dd>

<br><ul>
	<li>i comandi stop e reactivate possono essere eseguiti solo se il robot sta già eseguendo un task e deve essere eseguito dal maître prima il comando stop ed in seguito reactivate. Come fa il robot a gestire questi comandi mentre sta eseguendo un task?</li>
</ul>

</dl></li>
<li><dl>
	<dt>Maitre</dt>
	<dd></dd>
	<dd>The software running on the maitre's smartphone must provide an user interface to allow the user (maitre) to interact with the system. This software may be a native (android or IOS) or a web application running on a mobile browser.
	
	<br>(Dopo un'interazione col cliente/Dopo una attenta valutazione dei mezzi disponibili per progettare questo software, è risultato più opportuno l'utilizzo di una web application, in quanto risulta uno strumento più versatile)</dd>
</dl></li>
<li><dl>
	<dt>Fridge</dt>
	<dd>The requirements specify that the fridge must comunicate through CoAP protocol. This can be easily obtained, with the QAK framework, sending a normal dispatch to another actor running on another context. The software running on the fridge context should comunicate via dispatch (CoAP) with the actors running on other contexts.</dd>
</dl></li>
</ol>

<h3>(2) Model of system's logical architecture</h3>
Define (a model of) the logical architecture of the system

<ol start="2">
<li>Model of the logical architecture of the system:</li>
</ol>

<h3>(3) Test Plan</h3>
Refine the set of functional TestPlan

<ol start="3">
<li>Functional TestPlan:</li>
</ol>

<h3>(4) SCRUM context</h3>

In the context of SCRUM:<ul>
	<li>define a (first) product backlog</li>
	<li>a possibile set/sequence of SPRINT</li>
</ul>

<ol start="4">
<li>In the context of SCRUM:
	<ul>
	<li>First product backlog:</li>
	<ol>
	<li></li>
	</ol>
	<li>Possibile set/sequence of SPRINT:</li>
	<ol>
	<li></li>
	</ol>
	</ul>
</li>
</ol>

<h4>Product Backlog</h4>

A first Product Backlog can be:
<ol>
	<li>planning</li>
	<li>RBR moving</li>
	<li>prepare the room task</li>
	<li>add food task</li>
	<li>clear task</li>
	<li>sonar</li>
	<li>mapping</li>
	<li>rbr avoid obstacles</li>
	<li>managing resources (actors + state manager??)</li>
	<li>consult</li>
	<li>stop/reactivate</li>
	<li>gui matre's smartphone software</li>
	<li>Deployment</li>
	<li>Maintenance</li>
</ol>

<h4>first SPRINT sequence</h4>

A possibile set/sequence of SPRINT can be:
<dl>
<dt>SPRINT 0</dt>
<dd><ol>
	<li>Planning: insert an initial map representation and use of Planner</li>
	<li>Integration of Basic Robot for the RBR</li>
	<li>Prepare the room task</li>
	<li>Add Food task</li>
	<li>Clear the room task</li>
	<li>Tests</li>
</ol></dd>
<dt>SPRINT 1</dt>
<dd><ol>
	<li>Sonar</li>
	<li>Mapping</li>
	<li>Avoid the obstacles requirement</li>
	<li>Tests</li>
</ol></dd>
<dt>SPRINT 2</dt>
<dd><ol>
	<li>Resources representation: an actor for each non-smart resource + State Manager??</li>
	<li>Consult</li>
	<li>Tests</li>
</ol></dd>
<dt>SPRINT 3</dt>
<dd><ol>
	<li>Stop/Reactivate</li>
	<li>Tests</li>
</ol></dd>
<dt>SPRINT 4</dt>
<dd><ol>
	<li>gui matre's smartphone software</li>
	<li>Tests</li>
</ol></dd>
<dt></dt>
<dd></dd>
</dl>

<h2>Test plans</h2> 


<h2>Project</h2> 



<h2>Testing</h2> 
 

<h2>Deployment</h2> 

 
<h2>Maintenance</h2> 

</div>
<br><br>
<div class="endpage">
By Romeo Stefano (stefano.romeo@studio.unibo.it) and Russo Maria (maria.russo10@studio.unibo.it)<br>
<img class="photo" src="./utils/img/StefanoRomeo.png" alt="Stefano Romeo image">
<img class="photo" src="./utils/img/MariaRusso.png" alt="Maria Russo image">

</div>

<div>elementi utili:</div>
Table:
<table>
<tr>
	<td></td>
	<td></td>
</tr>
</table>
Sorted List:
<ol>
<li></li>
<li></li>
</ol>
Unordered List:
<ul>
<li></li>
<li></li>
</ul>
Definition list:
<dl>
<dt></dt>
<dd></dd>
</dl>
Link:
<a href="" target="_blank"></a>
IFrame:
<iframe src="./src" title="title">"Link"/Cosa c'è nel frame</iframe>
<br>Image:
<img src="./utils/img/Nome.png" alt="description">
<br>Key words:
<ks></ks>
<br>commands:
<em></em>
</body>
</html>
