<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<link rel="stylesheet" type="text/css" href="./utils/style.css">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<base href=".">
<title>RomeoRussoStandingBuffetService</title>
</head>

<body>

<div id="top">
<h1>SPRINT 3 - STANDING BUFFET SERVICE | Ingegneria dei Sistemi Software</h1>
</div>

<div class="body">

<h2>Introduction</h2>

The starting point for this SPRINT is the resulting model from the <a href="../../../Sprint_2/SPRINT_2/userDocs/SPRINT_2.html#Sprint2Mod" target="_blank">previous Sprint 2</a>:
<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		Sprint 2 <a href="../../../Sprint_2/SPRINT_2/src/model.qak" target="_blank">model.qak</a><br>
		<pre><iframe class="qakSprint" src="../../../Sprint_2/SPRINT_2/src/model.qak" title="Sprint_2_Model">Model of Sprint 2</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="../../../Sprint_1/SPRINT_1/userDocs/utils/img/ModelSprint1_Legend.png" alt="Legend of the Logical Architecture System Model from Sprint 2"><br>
		<img src="../../../Sprint_2/SPRINT_2/userDocs/utils/img/ModelSprint_2.svg" alt="Logical Architecture System Model from Sprint 2">
	</td>
</tr>
</table>

<h2>Goal</h2>

<div class="remark">
<ol>
	<li><tt>GUI</tt> for <ks>maître's smartphone</ks> software</li>
</ol>
</div>

<h2><a name="PrAn_Sprint3"></a>Problem Analysis</h2>

<h3>GUI for Maître's Smartphone Software</h3>

By <a href="../../../ProblemAnalysisModel/userDocs/utils/tf/TemaFinaleBo19.html" target="_blank">requirements</a>, the user (<ks>Maître de Salle</ks>) must be able to interact with the system software, produced in the previous Sprints, through his/her smartphone (<ks>maître's smartphone</ks>).<br>

To do that, as already said in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnMaitre" target="_blank">initial problem analysis</a>, the software running on the <ks>maître's smartphone</ks> must provide a <tt>graphic user interface</tt> (<tt>GUI</tt>) and could be realized as a native application (<tt>Android</tt> or <tt>IOS</tt>) or a <tt>web application</tt> running on a mobile browser; the last one, after a careful evaluation of the available means to design this software, results to be the more appropriate, as it appears to be a more versatile tool.
<br><br>
Therefore, to to solve this sprint goal, the main problems which must be addressed are:
<ul>
	<li>how to change the <tt>mock</tt> <k>maitre</k> <tt>actor</tt> in a non-mock <tt>actor</tt> to receive commands in order to allow the user to interact with it through the <tt>GUI</tt>;</li>
	<li>which architecture could be used to represent the system;</li>
	<li>how to realize the <tt>GUI</tt> as a <tt>web application</tt>;</li>
	<li>how the <tt>GUI</tt> (<tt>web application</tt>) and the <k>maitre</k> <tt>actor</tt> must communicate.</li>
</ul>

<h4><a name="PrAn_S3_maitre"></a>Maitre</h4>

To redesigned the <k>maitre</k> as a non-mock <tt>actor</tt> there are different ways available:
<ol>
	<li>its behavior could be assimilated by the <tt>GUI</tt>; but this is not the most adaptive solution because it fixes the <k>maitre</k> <tt>actor</tt> behavior with the <tt>GUI</tt> preventing the interaction with a different interface mechanism free by this behavior and representing an obstacle for possible future extensions;</li>
	<li><a name="sol2_maitre"></a>the <k>maitre</k> <tt>actor</tt> could be a non-mock <tt>actor</tt>, which maintains its behavior with the other system <tt>actors</tt>, but it can also receive external commands (in this case from the <tt>GUI</tt>) as long as the interface mechanism supports the same type of messages exchange.</li>
</ol>
Therefore, the <a href="./SPRINT_3.html#sol2_maitre">second solution</a> seems to be the most appropriate because it results the most versatile one for interacting with a different interface mechanism and for possible future extensions.

<h4>System Architecture</h4>

This application could be developed using the <tt>MVC</tt> (<tt>Model-View-Controller</tt>) pattern and making sure the system architecture respects the <tt>hexagonal architecture</tt>, which allows the communications between the <tt>front-end</tt> and the <tt>back-end</tt> by inserting an <tt>adapter object</tt>: in this way, the <tt>web application</tt> (<tt>front-end</tt>) can communicate with the <k>maitre</k> <tt>actor</tt> (<tt>back-end</tt>) through the <tt>adapter object</tt>.<br>
For example, the user (<ks>Maître de Salle</ks>) could select elements on the <tt>view</tt>, which can be read by the <tt>controller</tt>, which can communicate with the <k>maitre</k> <tt>actor</tt> through the <tt>adapter object</tt>.

<h4><a name="PrAn_S3_GUI"></a>GUI - Web Application</h4>

This <tt>web application</tt> could be realized using <tt>Spring framework</tt> which provides a good support to <tt>web application</tt> development and to the <tt>MVC</tt> pattern for the system architecture proposed above.

<h4>Communications</h4>

As already said above, the <tt>adapter object</tt> allow the communications between the two parts (<tt>front-end</tt> and <tt>back-end</tt>); this can be done in different ways through different protocols (<tt>TCP</tt>, <tt>MQTT</tt>, <tt>CoAP</tt>).<br>
After a careful evaluation, this could be realized using:
<ul>
	<li>the <tt>TCP</tt>, <tt>MQTT</tt> or <tt>CoAP</tt> protocol for the communication to the <k>maitre</k> <tt>actor</tt>;</li>
	<li>the <tt>CoAP</tt> protocol for the communication from the <k>maitre</k> <tt>actor</tt>, so to make possible for everyone to observe its state.</li>
</ul>
In this way: the <tt>controller</tt> through the <tt>adapter object</tt> sends messages (<ko>dispatch</ko>) to the <k>maitre</k>, which, when necessary, updates its state (through the <ko>updateResource</ko> command) so to make possible for the <tt>adapter object</tt> to read it via <tt>CoAP</tt> and to communicate it to the <tt>controller</tt>.

<br><br>
<img src="./utils/img/PrAn_CommunicationGuiMaitre.svg" alt="Communications GUI Maitre">

<h2>Test Plans</h2>

With reference to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnTestPlans" target="_blank">initial problem analysis test plans</a>, below it's reported a functional tests planning related to the goal of this sprint:
<br><br>
<ul>
	<li>Tests of all the communications between entities;</li>
	<li>Tests of the mutual exclusion of <ks>tasks</ks> and of their order of execution;</li>
	<li>Tests of the <em>stop</em> and <em>reactivate</em> commands that can be used by <ks>Maître de salle</ks> only when there is a running <ks>task</ks>.</li>
</ul>

<h2>Project</h2>

With regard to the <a href="./SPRINT_3.html#PrAn_Sprint3">problem analysis about this sprint</a>, in this design phase it has been necessary to redesign the <k>maitre</k> <tt>actor</tt>, which is not anymore a <tt>mock actor</tt>, and next to design and create a new project <a href="https://github.com/bluffgnuff/RomeoRussoISS2021/tree/master/Sprint_3/maitreGUI" target="_blank">maitreGUI</a> to realize the <tt>GUI</tt>, as a <tt>web application</tt>, for the <ks>maître's smartphone</ks> software.

<h3>Maitre</h3>

To not be anymore a <tt>mock actor</tt>, as said in the <a href="./SPRINT_3.html#PrAn_S3_maitre">problem analysis about this goal</a>, the <k>maitre</k> has been redesigned, maintaining its behavior with the other system <tt>actors</tt>, but adding the possibility to receive from the user (<ks>Maître de Salle</ks>), in this sprint through the <tt>web application</tt>, some external commands as <ko>dispatch</ko>:
<ul>
<li><em>prepare(<ac>Crockery</ac>, <ac>Food</ac>)</em>, where <ac>Crockery</ac> and <ac>Food</ac> are empty string or a list respectively of crockery and food (in case the user (<ks>Maître de Salle</ks>) defines through the <tt>GUI</tt> the elements for the <ks>task</ks> <ks>Prepare the room</ks>, as proposed in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnMaitre" target="_blank">initial problem analysis</a>): in the first case, as in the previous sprints, the <k>maitre</k> loads the default elements from the <tt>prolog</tt> file (<a href="https://raw.githubusercontent.com/bluffgnuff/RomeoRussoISS2021/master/Sprint_3/SPRINT_3/Prepare.pl" target="_blank">Prepare.pl</a>). Then it sends a <em>prepare</em> <ko>dispatch</ko> to the <k>rbr</k> specifing the (default or new) food and crockery;</li>
	<li><em>addFood(<ac>FOOD_CODE</ac>)</em>, where <ac>FOOD_CODE</ac> is the <ks>food-code</ks> defined by the user (<ks>Maître de Salle</ks>) for the <ks>task</ks> <ks>Add Food</ks>, as required in <a href="../../../ProblemAnalysisModel/userDocs/utils/tf/TemaFinaleBo19.html" target="_blank">requirements text</a> and as proposed in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnMaitre" target="_blank">initial problem analysis</a>: after receiving this command, the <k>maitre</k> sends an <em>addFood</em> <ko>request</ko> to the <k>rbr</k> specifing the <ac>FOOD_CODE</ac>;</li>
	<li><em>clear</em>: as in the previous sprints, the <k>maitre</k> sends a <em>consult</em> <ko>dispatch</ko> to the <k>table</k> to know the items (crockery and food) to remove and then it sends a <em>clear</em> <ko>dispatch</ko> to the <k>rbr</k> specifing those elements;</li>
	<li><em>consult</em>: as in the previous sprints, the <k>maitre</k> sends a <em>consult</em> <ko>dispatch</ko> to all the resources <tt>actors</tt> and waits for their answers;</li>
	<li><em>stop</em>: as in the previous sprints, the <k>maitre</k> sends a <em>stop</em> <ko>request</ko> to the <k>rbrwalker</k> and, only when the latter <ko>reply</ko> with <em>stopped(<ac>true</ac>)</em>, then the <k>maitre</k> waits for a <em>reactivate</em> <ko>dispatch</ko>. Here, it has been added the possibility to wait also a <em>consult</em>, but after the execution of this command, it's checked if it was in stop state and then the <k>maitre</k> waits again for a <em>reactivate</em> or <em>consult</em> <ko>dispatch</ko>;</li>
	<li><em>reactivate</em>: as in the previous sprints, it sends a <em>reactivate</em> <ko>dispatch</ko> to the <k>rbrwalker</k>;</li>
	<li><em>end</em>: it terminates itself.</li>
</ul>

<br>
<table>
<tr class="text">
	<th>Machine Understandable Models</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text" rowspan="3">
		<br><a href="../src/model.qak#:~:text=//QActor%20maitre%20context,terminating...%22)%0A%09%09terminate%201%0A%09%7D%0A%7D" target="_blank"><k>maitre</k> in model.qak</a><br><br>
		<iframe class="qakImageMax" src="./utils/img/Maitre.png" title="Maitre QActor from model.qak">Maitre QActor from model.qak</iframe>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ProjectTab_CommunicationGuiMaitre.svg" alt="Maitre Actor Context: communications with GUI">
	</td>
</tr>
<tr class="text">
	<th>Moore State Machine Diagrams</th>
</tr>
<tr>
	<td class="imageSchema">
		<img src="../../../ProblemAnalysisModel/userDocs/utils/img/ReqAnalysis/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
		<img src="./utils/img/FSM_MaitreQActor.svg" alt="Representation of the behavior of QActor maitre, modeled as a Moore state machine">
	</td>
</tr>
</table>

<h3>FoodConsumer</h3>

In this sprint the <k>foodconsumer</k> remains a <tt>mock actor</tt>, as done in the <a href="../../../Sprint_1/SPRINT_1/userDocs/SPRINT_1.html#S1FoodCons" target="_blank">first sprint</a>.<br>
In future, it could be improved making it not anymore a <tt>mock actor</tt> and redesigning it to better manage the food consumption.

<h3>MaitreGUI</h3>

To realize the <tt>GUI</tt>, as a <tt>web application</tt>, for the <ks>maître's smartphone</ks> software, it has been design and create a new project <a href="https://github.com/bluffgnuff/RomeoRussoISS2021/tree/master/Sprint_3/maitreGUI" target="_blank">maitreGUI</a>, using <tt>Spring framework</tt>, as already said in <a href="./SPRINT_3.html#PrAn_S3_GUI">the problem analysis of this goal</a>.<br>
In particular, it has been realized, starting from <a href="https://start.spring.io" target="_blank">Spring Boot</a>, a <tt>Gradle</tt> project using <tt>Spring Web</tt>, <tt>Spring Boot DevTools</tt> and <tt>Thymeleaf</tt> dependencies. (Useful the guides for <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/webspring.intro/userDocs/LabSpringUsageIntro2021.html" target="_blank">Spring Boot</a> and for <a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank">Thymeleaf</a>).

<br><br>
Spring Web: builds the web, including RESTful, applications using Spring MVC. Uses Apache Tomcat as the default embedded container.
<br>
Spring Boot DevTools: Provides fast application restarts, LiveReload, and configurations for enhanced development experience. Speeds up this refresh cycle (coding a change, restarting application, and refreshing the browser to view the change).
<br>
Thymeleaf: modern server-side Java template engine for both web and standalone environments. Allows HTML to be correctly displayed in browsers and as static prototypes
<br>
Spring framework: provides a good support to <tt>web application</tt> development and to the <tt>MVC</tt> pattern for the system architecture proposed in the problem analysis of this goal/sprint
<br>
Thymeleaf: modern server-side Java template engine for both web and standalone environments, capable to inject its logic into template files, like HTML, in a way that doesn’t affect the template from being used as a design prototype.
<br><br>

With regard of what said in the problem analysis of this sprint, this project is composed by: a package src/main/kotlin/it/unibo/maitreGUI with a controller (Controller.kt), an adapter object (MaitreResource.kt), a support for CoAP connection (CoapSupport.kt) and a main (MaitreGuiApplication.kt); a package src/main/kotlin/it/unibo/connQak with ...<br>
With regard of what said in the problem analysis of this sprint, in this project there are two packages in src/main/kotlin/it/unibo (maitreGUI and connQak) and in src/main/resources/templates there are the HTML files for which it has been used thimeleaf and GET methods to send informations.<br>
In particular, in the maitreGUI package there are:
<ul>
	<li>an adapter object (MaitreResource.kt), (which constructor (is) MaitreResource(name: String, addrdest: String, portdest: String, ctxdest: String, actordest: String, protocol: ConnectionType) (requires the ...) and) which offers methods to send messages (dispatch) to the maitre actor and to receive answers via CoAP;</li>
	<li>a controller (Controller.kt), which reads informations from the view (HTML files/pages) and uses the adapter object MaitreResource to communicate with the maitre actor. Here, it's also added the possibily to change the value to call the adapter object (like the address, the port and the context of the destination actor and the type of protocol (TCP, COAP, MQTT (implemented here but not maitre side/in the application software), HTTP(not yet implemented)) to communicate with it);</li>
	<li>a support for CoAP connection (CoapSupport.kt), used by the MaitreResource to can read the answers received by the maitre actor via CoAP;</li>
	<li>a main (MaitreGuiApplication.kt) to run the application.</li>
</ul>
In the connQak package there are:
<ul>
	<li>sysConnKb.kt, used to take and set the ... to use for the communications between MaitreResource and destination actor (maitre) (TCP, COAP, MQTT or HTTP (not implemented) to send messages and COAP to receive/read maitre state update);</li>
	<li>connQakBase.kt, which works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP and MQTT protocols;</li>
	<li>some classes (one for each type of connection) used by connQakBase.</li>
</ul>


<br><br>
APPUNTI:
The software it's realized as a web app using the Spring framework.<br>
The package it.unibo.connQak implements functions to send message to the actors with different protocols(in TCP, MQTT, CoAP, HTTP); the connQakBase works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP, MQTT protocols.<br>
The maitreResource  sends the commands to the maitre actor by TCP and receives the answers observing by CoAP the actor; in an hexagonal architecture this class is the use case. <br>
The controller works as a Spring controller and intercepts the Get request to execute the right behaviuor using maitreResource and showing the right HTML page.<br>
Immagine view => controller => maitreResource (use cases) <br>

<br><br>
APPUNTI:
<br><br>
To can receive dispatch messages from the controller through the adapter, the maitre actor doesn't must be anymore a mock client and so it must be redesigned.<br>
MaitreResource as adapter object
Controller as controller
Maitre.html, Maitre_page2 ... as interface using thimeleaf<br>

<h3>MaitreGui</h3>
The software it's realized as a web app using the Spring framework.<br>
The package it.unibo.connQak implements functions to send message to the actors with different protocols(in TCP, MQTT, CoAP, HTTP); the connQakBase works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP, MQTT protocols.<br>
The maitreResource  sends the commands to the maitre actor by TCP and receives the answers observing by CoAP the actor; in an hexagonal architecture this class is the use case. <br>
The controller works as a Spring controller and intercepts the Get request to execute the right behaviuor using maitreResource and showing the right HTML page.<br>
Immagine view => controller => maitreResource (use cases) <br>

<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Models</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text" rowspan="3">
		<br><a href="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/Controller.kt" target="_blank">Controller.kt</a><br><br>
		<iframe class="qakSprint2max" src="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/Controller.kt" title="Controller from maitreGUI project">Controller from maitreGUI project</iframe>
		<br><br><hr><br>
		<a href="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/MaitreResource.kt" target="_blank">MaitreResource.kt</a><br><br>
		<iframe class="qakSprint2max" src="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/MaitreResource.kt" title="MaitreResource from maitreGUI project">MaitreResource from maitreGUI project</iframe>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/CommunicationGuiMaitre.svg" alt="Communications between GUI (maitreGUI project) and maitre actor">
	</td>
</tr>
<tr class="text">
	<th>Moore State Machine Diagrams/htlm pages images??</th>
</tr>
<tr>
	<td class="imageSchema">
		<img src="../../../ProblemAnalysisModel/userDocs/utils/img/ReqAnalysis/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
		<img src="./utils/img/FSM_RBRMapperQActor.svg" alt="Representation of the behavior of QActor rbrmapper, modeled as a Moore state machine"><br>
		<img src="./utils/img/FSM_RBRQActor.svg" alt="Representation of the behavior of QActor rbr, modeled as a Moore state machine">
	</td>
</tr>
</table>

<h2>Testing</h2>

The tests for this sprint ...

non sono stati fatti in quanto il maitre/il funzionamento del sistema era già stato testato negli sprint precedenti; mentre per quanto riguarda la parte di GUI, questa può essere testata provando a inviare comandi al maitre tramite la web application.

<h2><a name="Sprint3Mod"></a>Model of System's Logical Architecture</h2>

<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		Sprint 3 <a href="../src/model.qak" target="_blank">model.qak</a><br>
		<pre><iframe class="qakSprint" src="../src/model.qak" title="ModelSprint_3">Model of Sprint 3</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ModelSprint3_Legend.svg" alt="Legend of the Logical Architecture System Model from Sprint 3"><br>
		<img src="./utils/img/ModelSprint_3.svg" alt="Logical Architecture System Model from Sprint 3">
	</td>
</tr>
</table>

<h2>Deployment</h2>



<h2>SCRUM Context</h2>

<h3>SPRINT Sequence</h3>

After this Sprint and according to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#ProdBack" target="_blank">Product Backlog</a>, listed after the problem analysis, a possibile set of next Sprint could be:
<dl>
	<dt>SPRINT 4</dt>
	<dd><ol>
		<li>Deploy on <tt>Raspberry</tt></li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Add Food</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Clear the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li>Tests</li>
	</ol></dd>
</dl>

<div hidden="hidden">
<h2>Maintenance</h2>
</div>

</div>
<br><br>
<div class="endpage">
By Romeo Stefano (stefano.romeo@studio.unibo.it) and Russo Maria (maria.russo10@studio.unibo.it)<br>
<img class="photo" src="../../../userDocs/utils/img/StefanoRomeo.png" alt="Stefano Romeo image">
<img class="photo" src="../../../userDocs/utils/img/MariaRusso.png" alt="Maria Russo image">
</div>

<div hidden="hidden">elementi utili:
Table:
<table>
<tr>
	<td></td>
	<td></td>
</tr>
</table>
Sorted List:
<ol>
<li></li>
<li></li>
</ol>
Unordered List:
<ul>
<li></li>
<li></li>
</ul>
Definition list:
<dl>
<dt></dt>
<dd></dd>
</dl>
Link:
<a href="" target="_blank"></a>
Link in pagina:
<a name="link"></a> + <a href="./SPRINT_2.html#link">text</a>
IFrame:
<iframe src="./src" title="title">"Link"/Cosa c'è nel frame</iframe>
<br>Image:
<img src="./utils/img/Nome.png" alt="description">
</div>

</body>
</html>
