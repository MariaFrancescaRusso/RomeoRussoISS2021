<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<link rel="stylesheet" type="text/css" href="./utils/style.css">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<base href=".">
<title>RomeoRussoStandingBuffetService</title>
</head>

<body>

<div id="top">
<h1>SPRINT 3 - STANDING BUFFET SERVICE | Ingegneria dei Sistemi Software</h1>
</div>

<div class="body">

<h2>Introduction</h2>

The starting point for this SPRINT is the resulting model from the <a href="../../../Sprint_2/SPRINT_2/userDocs/SPRINT_2.html#Sprint2Mod" target="_blank">previous Sprint 2</a>:
<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		Sprint 2 <a href="../../../Sprint_2/SPRINT_2/src/model.qak" target="_blank">model.qak</a><br>
		<pre><iframe class="qakSprint" src="../../../Sprint_2/SPRINT_2/src/model.qak" title="Sprint_2_Model">Model of Sprint 2</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="../../../Sprint_1/SPRINT_1/userDocs/utils/img/ModelSprint1_Legend.png" alt="Legend of the Logical Architecture System Model from Sprint 2"><br>
		<img src="../../../Sprint_2/SPRINT_2/userDocs/utils/img/ModelSprint_2.svg" alt="Logical Architecture System Model from Sprint 2">
	</td>
</tr>
</table>

<h2>Goal</h2>

<div class="remark">
<ol>
	<li><tt>GUI</tt> for <ks>maître's smartphone</ks> software</li>
</ol>
</div>

<h2>Problem Analysis</h2>

<h3>GUI for Maître's Smartphone Software</h3>

By <a href="../../../ProblemAnalysisModel/userDocs/utils/tf/TemaFinaleBo19.html" target="_blank">requirements</a>, the user (<ks>Maître de Salle</ks>) must be able to interact with the system software, produced in the previous Sprints, through his/her smartphone (<ks>maître's smartphone</ks>).<br>

To do that, as already said in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnMaitre" target="_blank">initial problem analysis</a>, the software running on the <ks>maître's smartphone</ks> must provide a graphic user interface (GUI) and could be a native application (<tt>Android</tt> or <tt>IOS</tt>) or a <tt>web</tt> application running on a mobile browser; the last one, after a careful evaluation of the available means to design this software, results to be the more appropriate, as it appears to be a more versatile tool.
<br><br>
Therefore, to to solve this sprint goal, the main problem which/that must be addressed are detailed below. / 
Therefore, to to solve this sprint goal, the main problem which must be addressed are: how to realize the GUI that will be a web application and so which architecture will/should be represented; how the two parts (GUI/web application and system application??, so the maitre actor of the system application) must communicate; how to change the mock maitre actor in an actor.

<h3>GUI for Maître's Smartphone Software</h3>

This web application con be realize as a gradle project using Spring.?? (Qua o nella parte di progetto?)

<h4>System Architecture</h4>

This application could be developed using the MVC (Model-View-Controller) pattern and making sure the system architecture respects the hexagonal architecture, which allows the communications between the front-end and the back-end by inserting an adapter object.
In this way, the web application (front-end) can communicate with the system application (back-end) through the adapter object: the user can select elements on the web interface (view), which can be read by the controller, which can communicate with the (model?) maitre actor through the adapter object.

<h4>Communications</h4>

As already said the adapter object allow the communications between the two parts (front-end and back-end); this can be done in different ways through different protocols (TCP, MQTT, CoAP). With regard to the previous choices, the more appropriate way to realize this could be the using of the CoAP protocol: the controller through the adapter object sends messages (dispatch) to the maitre, which, when necessary, updates its state (through the updateResource command) so to make possible for the adapter object to read it via CoAP and to commnicate it to the controller.

<h4>Maitre</h4>

To can receive dispatch messages from the controller through the adapter, the maitre actor doesn't must be anymore a mock client and so it must be redesigned.

<br><br>
<img src="./utils/img/PrAn_CommunicationGuiMaitre.svg" alt="Communications GUI Maitre">

<br><br>
APPUNTI:
<br><br>
The maitre software sends and recevies the same messages and events of the mock maitre in the previous Sprint. To realize it, it's possible to develop an actor which recives, through messages, the commands to send to the other system elements.
<br><br>
Scaletta:
	- soluzione:
			- View: html-tymeleaf
			- Controller: Spring, chiama Adapter
			- Adapter: osserva via CoAP il maitre per leggere aggiornamento stato del maitre
			- Model: Maitre actor, che aggiorna il proprio stato (updateResource)

<h2>Test Plans</h2>

With reference to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnTestPlans" target="_blank">initial problem analysis test plans</a>, below it's reported a functional tests planning related to the goal of this sprint:
<br><br>
<ul>
	<li>Tests of all the communications between entities;</li>
	<li>Tests of the mutual exclusion of <ks>tasks</ks> and of their order of execution;</li>
	<li>Tests of the <em>stop</em> and <em>reactivate</em> commands that can be used by <ks>Maître de salle</ks> only when there is a running <ks>task</ks>.</li>
</ul>

<h2>Project</h2>

With regard to what it has been said in the problem analysis of this sprint, in this design phase it has been redesigned the maitre actor, which is not anymore a mock actor and then it has been designed the GUI for the maitre smartphone software ??.

<h3>Maitre</h3>

The maitre actor in this sprint has been redesigned to not be (anymore) a mock actor. In particular, it maintains its behavior but now it can receive (from the web application, and in particular from the controller through the adapter object) some commands/messages as dispatch: prepare; addFood; clear; consult; stop; reactivate; end.<br>

In detail, when it receives the message:
<ul>
	<li>prepare(Crockery, Food), where Crockery and Food are empty string or a list respectively of crockery and food; so to allow/to add the possibility for the maitre to insert/decide/select the elements for the task Prepare the room, as said in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnMaitre" target="_blank">initial problem analysis</a>. As for/in the previous sprints, for the first case, the maitre actor loads the default elements from the prolog file (Prepare.pl); otherwise it use the new elements. Then it sends the prepare message to the rbr specifing the (default or new) food and crockery;</li>
	<li>prepare(Crockery, Food), where Crockery and Food are empty string or a list respectively of crockery and food. In the latter case, the prolog file (Prepare.pl) is updated with the new elements. Then, as for/in the previous sprints, the maitre actor loads the (default or new) elements from the prolog file (Prepare.pl) and sends the prepare message to the rbr specifing that food and crockery elements;</li>
	<li>addFood(FOOD_CODE), where FOOD_CODE is the food code; so to allow/to add the possibility for the maitre to insert/decide/select the food code for the task Add Food. The prolog file (Prepare.pl) is updated with the new element/food code. Them, as for/in the previous sprints, the maitre actor loads the new element from the prolog file (Prepare.pl) and sends the addFood message/request to the rbr specifing the food code;</li>
	<li>addFood(FOOD_CODE), where FOOD_CODE is the food code used by the maitre actor to send the addFood message/request to the rbr;</li>
	<li>clear: as for/in the previous sprints, the maitre actor sends the consult message/dispatch to the table to get/know the items (crockery and/or food) to remove and then it sends the clear message/dispatch to the rbr specifing that food and crockery elements;</li>
	<li>consult: as for/in the previous sprints, the maitre actor sends the consult message/dispatch to all resources and waits for their answers;</li>
	<li>stop: as for/in the previous sprints, the maitre actor sends the stop message/request to the rbrwalker and only when it receives from the rbrwalker the stopped(true) reply then it waits for the reactivate message/dispatch. Here, it has been added the possibility to wait also a consult, but at the end of this case, it checks if it was in stop state and then it wait again for a reactivate or consult message/dispatch;</li>
	<li>reactivate: as for/in the previous sprints, it sends the reactivate message/dispatch to the rbrwalker;</li>
	<li>end: it terminates itself.</li>
</ul>

<br>
<table>
<tr class="text">
	<th>Machine Understandable Models</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text" rowspan="3">
		<br><a href="../src/model.qak#:~:text=//QActor%20maitre%20context,terminating...%22)%0A%09%09terminate%201%0A%09%7D%0A%7D" target="_blank"><k>maitre</k> in model.qak</a><br><br>
		<iframe class="qakImageMax" src="./utils/img/Maitre.png" title="Maitre QActor from model.qak">Maitre QActor from model.qak</iframe>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ProjectTab_CommunicationGuiMaitre.svg" alt="Maitre Actor Context: communications with GUI">
	</td>
</tr>
<tr class="text">
	<th>Moore State Machine Diagrams</th>
</tr>
<tr>
	<td class="imageSchema">
		<img src="../../../ProblemAnalysisModel/userDocs/utils/img/ReqAnalysis/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
		<img src="./utils/img/FSM_MaitreQActor.svg" alt="Representation of the behavior of QActor maitre, modeled as a Moore state machine">
	</td>
</tr>
</table>

<h3>GUI</h3>

The software of / This web application has been realized as a gradle project (MaitreGUI) using Spring./as a web app using the Spring framework.<br>
With regard of what said in the problem analysis of this sprint, this project is composed by: a package src/main/kotlin/it/unibo/maitreGUI with a controller (Controller.kt), an adapter object (MaitreResource.kt), a support for CoAP connection (CoapSupport.kt) and a main (MaitreGuiApplication.kt); a package src/main/kotlin/it/unibo/connQak with ...<br>
With regard of what said in the problem analysis of this sprint, in this project there are two packages in src/main/kotlin/it/unibo (maitreGUI and connQak) and in src/main/resources/templates there are the HTML files for which it has been used thimeleaf and GET methods to send informations.<br>
In particular, in the maitreGUI package there are:
<ul>
	<li>an adapter object (MaitreResource.kt), (which constructor (is) MaitreResource(name: String, addrdest: String, portdest: String, ctxdest: String, actordest: String, protocol: ConnectionType) (requires the ...) and) which offers methods to send messages (dispatch) to the maitre actor and to receive answers via CoAP;</li>
	<li>a controller (Controller.kt), which reads informations from the view (HTML files/pages) and uses the adapter object MaitreResource to communicate with the maitre actor. Here, it's also added the possibily to change the value to call the adapter object (like the address, the port and the context of the destination actor and the type of protocol (TCP, COAP, MQTT (implemented here but not maitre side/in the application software), HTTP(not yet implemented)) to communicate with it);</li>
	<li>a support for CoAP connection (CoapSupport.kt), used by the MaitreResource to can read the answers received by the maitre actor via CoAP;</li>
	<li>a main (MaitreGuiApplication.kt) to run the application.</li>
</ul>
In the connQak package there are:
<ul>
	<li>sysConnKb.kt, used to take and set the ... to use for the communications between MaitreResource and destination actor (maitre) (TCP, COAP, MQTT or HTTP (not implemented) to send messages and COAP to receive/read maitre state update);</li>
	<li>connQakBase.kt, which works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP and MQTT protocols;</li>
	<li>some classes (one for each type of connection) used by connQakBase.</li>
</ul>


<br><br>
APPUNTI:
The software it's realized as a web app using the Spring framework.<br>
The package it.unibo.connQak implements functions to send message to the actors with different protocols(in TCP, MQTT, CoAP, HTTP); the connQakBase works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP, MQTT protocols.<br>
The maitreResource  sends the commands to the maitre actor by TCP and receives the answers observing by CoAP the actor; in an hexagonal architecture this class is the use case. <br>
The controller works as a Spring controller and intercepts the Get request to execute the right behaviuor using maitreResource and showing the right HTML page.<br>
Immagine view => controller => maitreResource (use cases) <br>

<br><br>
APPUNTI:
<br><br>
To can receive dispatch messages from the controller through the adapter, the maitre actor doesn't must be anymore a mock client and so it must be redesigned.<br>
MaitreResource as adapter object
Controller as controller
Maitre.html, Maitre_page2 ... as interface using thimeleaf<br>
The maitre actor waits for the messages: prepare, consult, addFood, clear, stop, end. When it receives the message:
<ul>
    <li>prepare: sends the prepare message to the rbr specifing the food and the crockery;</li>
    <li>addFood: sends the addFood message to the rbr specifing the food;</li>
    <li>clear: sends the consult message to the table to get the items to remove; sends the clear message to the rbr specifing the food and the crockery;</li>
    <li>consult: sends the consult message to all resources and waits for their answers;</li>
    <li>stop: sends the stop message to the rbr when this is received it waits just for the reactivate message;</li>
    <li>reactivate: sends the reactivate message to the rbr;</li>
    <li>end: sends the end message to the rbr and terminate.</li>
</ul>

<h3>MaitreGui</h3>
The software it's realized as a web app using the Spring framework.<br>
The package it.unibo.connQak implements functions to send message to the actors with different protocols(in TCP, MQTT, CoAP, HTTP); the connQakBase works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP, MQTT protocols.<br>
The maitreResource  sends the commands to the maitre actor by TCP and receives the answers observing by CoAP the actor; in an hexagonal architecture this class is the use case. <br>
The controller works as a Spring controller and intercepts the Get request to execute the right behaviuor using maitreResource and showing the right HTML page.<br>
Immagine view => controller => maitreResource (use cases) <br>

<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Models</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text" rowspan="3">
		<br><a href="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/Controller.kt" target="_blank">Controller.kt</a><br><br>
		<iframe class="qakSprint2max" src="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/Controller.kt" title="Controller from maitreGUI project">Controller from maitreGUI project</iframe>
		<br><br><hr><br>
		<a href="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/MaitreResource.kt" target="_blank">MaitreResource.kt</a><br><br>
		<iframe class="qakSprint2max" src="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/MaitreResource.kt" title="MaitreResource from maitreGUI project">MaitreResource from maitreGUI project</iframe>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/CommunicationGuiMaitre.svg" alt="Communications between GUI (maitreGUI project) and maitre actor">
	</td>
</tr>
<tr class="text">
	<th>Moore State Machine Diagrams/htlm pages images??</th>
</tr>
<tr>
	<td class="imageSchema">
		<img src="../../../ProblemAnalysisModel/userDocs/utils/img/ReqAnalysis/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
		<img src="./utils/img/FSM_RBRMapperQActor.svg" alt="Representation of the behavior of QActor rbrmapper, modeled as a Moore state machine"><br>
		<img src="./utils/img/FSM_RBRQActor.svg" alt="Representation of the behavior of QActor rbr, modeled as a Moore state machine">
	</td>
</tr>
</table>

<h2>Testing</h2>

The tests for this sprint ...

non sono stati fatti in quanto il maitre/il funzionamento del sistema era già stato testato negli sprint precedenti; mentre per quanto riguarda la parte di GUI, questa può essere testata provando a inviare comandi al maitre tramite la web application.

<h2><a name="Sprint3Mod"></a>Model of System's Logical Architecture</h2>

<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		Sprint 3 <a href="../src/model.qak" target="_blank">model.qak</a><br>
		<pre><iframe class="qakSprint" src="../src/model.qak" title="ModelSprint_3">Model of Sprint 3</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ModelSprint3_Legend.svg" alt="Legend of the Logical Architecture System Model from Sprint 3"><br>
		<img src="./utils/img/ModelSprint_3.svg" alt="Logical Architecture System Model from Sprint 3">
	</td>
</tr>
</table>

<h2>Deployment</h2>



<h2>SCRUM Context</h2>

<h3>SPRINT Sequence</h3>

After this Sprint and according to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#ProdBack" target="_blank">Product Backlog</a>, listed after the problem analysis, a possibile set of next Sprint could be:
<dl>
	<dt>SPRINT 4</dt>
	<dd><ol>
		<li>Deploy on <tt>Raspberry</tt></li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Add Food</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Clear the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li>Tests</li>
	</ol></dd>
</dl>

<div hidden="hidden">
<h2>Maintenance</h2>
</div>

</div>
<br><br>
<div class="endpage">
By Romeo Stefano (stefano.romeo@studio.unibo.it) and Russo Maria (maria.russo10@studio.unibo.it)<br>
<img class="photo" src="../../../userDocs/utils/img/StefanoRomeo.png" alt="Stefano Romeo image">
<img class="photo" src="../../../userDocs/utils/img/MariaRusso.png" alt="Maria Russo image">
</div>

<div hidden="hidden">elementi utili:
Table:
<table>
<tr>
	<td></td>
	<td></td>
</tr>
</table>
Sorted List:
<ol>
<li></li>
<li></li>
</ol>
Unordered List:
<ul>
<li></li>
<li></li>
</ul>
Definition list:
<dl>
<dt></dt>
<dd></dd>
</dl>
Link:
<a href="" target="_blank"></a>
Link in pagina:
<a name="link"></a> + <a href="./SPRINT_2.html#link">text</a>
IFrame:
<iframe src="./src" title="title">"Link"/Cosa c'è nel frame</iframe>
<br>Image:
<img src="./utils/img/Nome.png" alt="description">
</div>

</body>
</html>
