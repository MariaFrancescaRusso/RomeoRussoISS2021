<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<link rel="stylesheet" type="text/css" href="./utils/style.css">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<base href=".">
<title>RomeoRussoStandingBuffetService</title>
</head>

<body>

<div id="top">
<h1>SPRINT 3 - STANDING BUFFET SERVICE | Ingegneria dei Sistemi Software</h1>
</div>

<div class="body">

<h2>Introduction</h2>

The starting point for this SPRINT is the resulting model from the <a href="../../../Sprint_2/SPRINT_2/userDocs/SPRINT_2.html#Sprint2Mod" target="_blank">previous Sprint 2</a>:
<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		Sprint 2 <a href="../../../Sprint_2/SPRINT_2/src/model.qak" target="_blank">model.qak</a><br>
		<pre><iframe class="qakSprint" src="../../../Sprint_2/SPRINT_2/src/model.qak" title="Sprint_2_Model">Model of Sprint 2</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="../../../Sprint_1/SPRINT_1/userDocs/utils/img/ModelSprint1_Legend.png" alt="Legend of the Logical Architecture System Model from Sprint 2"><br>
		<img src="../../../Sprint_2/SPRINT_2/userDocs/utils/img/ModelSprint_2.svg" alt="Logical Architecture System Model from Sprint 2">
	</td>
</tr>
</table>

<h2>Goal</h2>

<div class="remark">
<ol>
	<li><tt>GUI</tt> for <ks>maître's smartphone</ks> software</li>
</ol>
</div>

<h2>Problem Analysis</h2>

<h3>GUI for Maître's Smartphone Software</h3>

By <a href="../../../ProblemAnalysisModel/userDocs/utils/tf/TemaFinaleBo19.html" target="_blank">requirements</a>, the user (<ks>Maître de Salle</ks>) must be able to interact with the system software, produced in the previous Sprints, through his/her smartphone (<ks>maître's smartphone</ks>).<br>

To do that, as already said in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnMaitre" target="_blank">initial problem analysis</a>, the software running on the <ks>maître's smartphone</ks> must provide a <tt>graphic user interface</tt> (<tt>GUI</tt>) and could be realized as a native application (<tt>Android</tt> or <tt>IOS</tt>) or a <tt>web</tt> application running on a mobile browser; the last one, after a careful evaluation of the available means to design this software, results to be the more appropriate, as it appears to be a more versatile tool.
<br><br>
Therefore, to to solve this sprint goal, the main problems which must be addressed are:
<ul>
	<li>how to change the <tt>mock</tt> <k>maitre</k> <tt>actor</tt> in a <ko>in verde??</ko>non-mock <tt>actor</tt> to receive commands in order to allow the user to interact with it through the <tt>GUI</tt>;</li>
	<li>which architecture could be used to represent the system;</li>
	<li>how to realize the <tt>GUI</tt> as a <tt>web</tt> <ko>in verde??</ko>application;</li>
	<li>how the <tt>GUI</tt> (<tt>web</tt> <ko>in verde??</ko>application) and the <k>maitre</k> <tt>actor</tt> must communicate.</li>
</ul>

<h4>Maitre</h4>

To redesigned the <k>maitre</k> as a <ko>in verde??</ko> non-mock <tt>actor</tt> there are different ways available:
<ol>
	<li>its behavior could be assimilated by the <tt>GUI</tt>; but this is not the most adaptive solution because it fixes the <k>maitre</k> <tt>actor</tt> behavior with the <tt>GUI</tt> preventing the interaction with a different interface mechanism free by this behavior and representing an obstacle for possible future extensions;</li>
	<li><a name="sol2_maitre"></a>the <k>maitre</k> <tt>actor</tt> could be a <ko>in verde??</ko>non-mock <tt>actor</tt>, which maintains its behavior with the other system <tt>actors</tt>, but it can also receive external commands (in this case from the <tt>GUI</tt>) as long as the interface mechanism supports the same type of messages exchange.</li>
</ol>
Therefore, the <a href="./SPRINT_3.html#sol2_maitre">second solution</a> seems to be the most appropriate because it results the most versatile one for interacting with a different interface mechanism and for possible future extensions.

<h4>System Architecture</h4>

This application could be developed using the <tt>MVC</tt> (<tt>Model</tt>-<tt>View</tt>-<tt>Controller</tt>) <ko>in verde??</ko>pattern and making sure the system architecture respects the <tt>hexagonal architecture</tt>, which allows the communications between the <ko>in verde??</ko>front-end and the <ko>in verde??</ko>back-end by inserting an <tt>adapter object</tt>: in this way, the <tt>web</tt> <ko>in verde??</ko>application (<ko>in verde??</ko>front-end) can communicate with the <k>maitre</k> <tt>actor</tt> (<ko>in verde??</ko>back-end) through the <tt>adapter object</tt>. For example, the user<ko>Maitre de salle??</ko> could select elements on the <tt>web</tt> <ko>in verde??</ko>interface (<tt>view</tt>), which can be read by the <tt>controller</tt>, which can communicate with the (<tt>model</tt>) <k>maitre</k> <tt>actor</tt> through the <tt>adapter object</tt>.

<h4>GUI - Web Application</h4>

This <tt>web</tt> <ko>in verde??</ko>application could be realized using <tt>Spring framework</tt> which provides a good support to <tt>web</tt> <ko>in verde??</ko>application development and to the <tt>MVC</tt> <ko>in verde??</ko>pattern for the system architecture proposed above.

<h4>Communications</h4>

As already said above, the <tt>adapter object</tt> allow the communications between the two parts (<ko>in verde??</ko>front-end and <ko>in verde??</ko>back-end); this can be done in different ways through different protocols (<tt>TCP</tt>, <tt>MQTT</tt>, <tt>CoAP</tt>).<br>
After a careful evaluation, this could be realized using:
<ul>
	<li>the <tt>TCP</tt>, <tt>MQTT</tt> or <tt>CoAP</tt> protocol for the communication to the <k>maitre</k> <tt>actor</tt>;</li>
	<li>the <tt>CoAP</tt> protocol for the communication from the <k>maitre</k> <tt>actor</tt>, so to make possible for everyone to observe its state.</li>
</ul>
In this way: the <tt>controller</tt> through the <tt>adapter object</tt> sends messages (<ko>dispatch</ko>) to the <k>maitre</k>, which, when necessary, updates its state (through the <ko>updateResource</ko> command) so to make possible for the <tt>adapter object</tt> to read it via <tt>CoAP</tt> and to communicate it to the <tt>controller</tt>.

<br><br>
<img src="./utils/img/PrAn_CommunicationGuiMaitre.svg" alt="Communications GUI Maitre">

<h2>Test Plans</h2>

With reference to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnTestPlans" target="_blank">initial problem analysis test plans</a>, below it's reported a functional tests planning related to the goal of this sprint:
<br><br>
<ul>
	<li>Tests of all the communications between entities;</li>
	<li>Tests of the mutual exclusion of <ks>tasks</ks> and of their order of execution;</li>
	<li>Tests of the <em>stop</em> and <em>reactivate</em> commands that can be used by <ks>Maître de salle</ks> only when there is a running <ks>task</ks>.</li>
</ul>

<h2>Project</h2>

With regard to what it has been said in the problem analysis of this sprint, in this design phase it has been redesigned the maitre actor, which is not anymore a mock actor and then it has been designed the GUI for the maitre smartphone software ??.

<h3>Maitre</h3>

The maitre actor in this sprint has been redesigned to not be (anymore) a mock actor. In particular, it maintains its behavior but now it can receive (from the web application, and in particular from the controller through the adapter object) some commands/messages as dispatch: prepare; addFood; clear; consult; stop; reactivate; end.<br>

In detail, when it receives the message:
<ul>
	<li><em>prepare(<ac>Crockery</ac>, <ac>Food</ac>)</em>, where <ac>Crockery</ac> and <ac>Food</ac> are empty string or a list respectively of crockery and food; so to allow/to add the possibility for the maitre to insert/decide/select the elements for the <ks>task Prepare the room</ks>, as said in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnMaitre" target="_blank">initial problem analysis</a>. As for/in the previous sprints, for the first case, the <k>maitre</k> <tt>actor</tt> loads the default elements from the prolog file (Prepare.pl); otherwise it use the new elements. Then it sends the prepare message to the rbr specifing the (default or new) food and crockery;</li>
	<li><em>prepare(<ac>Crockery</ac>, <ac>Food</ac>)</em>, where <ac>Crockery</ac> and <ac>Food</ac> are empty string or a list respectively of crockery and food. In the latter case, the prolog file (Prepare.pl) is updated with the new elements. Then, as for/in the previous sprints, the maitre actor loads the (default or new) elements from the prolog file (Prepare.pl) and sends the prepare message to the rbr specifing that food and crockery elements;</li>
	<li><em>addFood(<ac>FOOD_CODE</ac>)</em>, where <ac>FOOD_CODE</ac> is the food code; so to allow/to add the possibility for the maitre to insert/decide/select the food code for the task Add Food. The prolog file (Prepare.pl) is updated with the new element/food code. Them, as for/in the previous sprints, the maitre actor loads the new element from the prolog file (Prepare.pl) and sends the addFood message/request to the rbr specifing the food code;</li>
	<li><em>addFood(<ac>FOOD_CODE</ac>)</em>, where <ac>FOOD_CODE</ac> is the food code used by the maitre actor to send the addFood message/request to the rbr;</li>
	<li><em>clear</em>: as for/in the previous sprints, the maitre actor sends the consult message/dispatch to the table to get/know the items (crockery and/or food) to remove and then it sends the clear message/dispatch to the rbr specifing that food and crockery elements;</li>
	<li><em>consult</em>: as for/in the previous sprints, the maitre actor sends the consult message/dispatch to all resources and waits for their answers;</li>
	<li><em>stop</em>: as for/in the previous sprints, the maitre actor sends the stop message/request to the rbrwalker and only when it receives from the rbrwalker the stopped(true) reply then it waits for the reactivate message/dispatch. Here, it has been added the possibility to wait also a consult, but at the end of this case, it checks if it was in stop state and then it wait again for a reactivate or consult message/dispatch;</li>
	<li><em>reactivate</em>: as for/in the previous sprints, it sends the reactivate message/dispatch to the rbrwalker;</li>
	<li><em>end</em>: it terminates itself.</li>
</ul>

<br>
<table>
<tr class="text">
	<th>Machine Understandable Models</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text" rowspan="3">
		<br><a href="../src/model.qak#:~:text=//QActor%20maitre%20context,terminating...%22)%0A%09%09terminate%201%0A%09%7D%0A%7D" target="_blank"><k>maitre</k> in model.qak</a><br><br>
		<iframe class="qakImageMax" src="./utils/img/Maitre.png" title="Maitre QActor from model.qak">Maitre QActor from model.qak</iframe>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ProjectTab_CommunicationGuiMaitre.svg" alt="Maitre Actor Context: communications with GUI">
	</td>
</tr>
<tr class="text">
	<th>Moore State Machine Diagrams</th>
</tr>
<tr>
	<td class="imageSchema">
		<img src="../../../ProblemAnalysisModel/userDocs/utils/img/ReqAnalysis/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
		<img src="./utils/img/FSM_MaitreQActor.svg" alt="Representation of the behavior of QActor maitre, modeled as a Moore state machine">
	</td>
</tr>
</table>

<h3>GUI - Web Application</h3>

The software of / This web application has been realized as a gradle project (MaitreGUI) using Spring./as a web app using the Spring framework 

(Spring Web: builds the web, including RESTful, applications using Spring MVC. Uses Apache Tomcat as the default embedded container. Spring Boot DevTools: Provides fast application restarts, LiveReload, and configurations for enhanced development experience. Speeds up this refresh cycle (coding a change, restarting application, and refreshing the browser to view the change).) and Thymeleaf (modern server-side Java template engine for both web and standalone environments. Allows HTML to be correctly displayed in browsers and as static prototypes )(usefull it has been the guide: https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/webspring.intro/userDocs/LabSpringUsageIntro2021.html).<br>

With regard of what said in the problem analysis of this sprint, this project is composed by: a package src/main/kotlin/it/unibo/maitreGUI with a controller (Controller.kt), an adapter object (MaitreResource.kt), a support for CoAP connection (CoapSupport.kt) and a main (MaitreGuiApplication.kt); a package src/main/kotlin/it/unibo/connQak with ...<br>
With regard of what said in the problem analysis of this sprint, in this project there are two packages in src/main/kotlin/it/unibo (maitreGUI and connQak) and in src/main/resources/templates there are the HTML files for which it has been used thimeleaf and GET methods to send informations.<br>
In particular, in the maitreGUI package there are:
<ul>
	<li>an adapter object (MaitreResource.kt), (which constructor (is) MaitreResource(name: String, addrdest: String, portdest: String, ctxdest: String, actordest: String, protocol: ConnectionType) (requires the ...) and) which offers methods to send messages (dispatch) to the maitre actor and to receive answers via CoAP;</li>
	<li>a controller (Controller.kt), which reads informations from the view (HTML files/pages) and uses the adapter object MaitreResource to communicate with the maitre actor. Here, it's also added the possibily to change the value to call the adapter object (like the address, the port and the context of the destination actor and the type of protocol (TCP, COAP, MQTT (implemented here but not maitre side/in the application software), HTTP(not yet implemented)) to communicate with it);</li>
	<li>a support for CoAP connection (CoapSupport.kt), used by the MaitreResource to can read the answers received by the maitre actor via CoAP;</li>
	<li>a main (MaitreGuiApplication.kt) to run the application.</li>
</ul>
In the connQak package there are:
<ul>
	<li>sysConnKb.kt, used to take and set the ... to use for the communications between MaitreResource and destination actor (maitre) (TCP, COAP, MQTT or HTTP (not implemented) to send messages and COAP to receive/read maitre state update);</li>
	<li>connQakBase.kt, which works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP and MQTT protocols;</li>
	<li>some classes (one for each type of connection) used by connQakBase.</li>
</ul>


<br><br>
APPUNTI:
The software it's realized as a web app using the Spring framework.<br>
The package it.unibo.connQak implements functions to send message to the actors with different protocols(in TCP, MQTT, CoAP, HTTP); the connQakBase works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP, MQTT protocols.<br>
The maitreResource  sends the commands to the maitre actor by TCP and receives the answers observing by CoAP the actor; in an hexagonal architecture this class is the use case. <br>
The controller works as a Spring controller and intercepts the Get request to execute the right behaviuor using maitreResource and showing the right HTML page.<br>
Immagine view => controller => maitreResource (use cases) <br>

<br><br>
APPUNTI:
<br><br>
To can receive dispatch messages from the controller through the adapter, the maitre actor doesn't must be anymore a mock client and so it must be redesigned.<br>
MaitreResource as adapter object
Controller as controller
Maitre.html, Maitre_page2 ... as interface using thimeleaf<br>
The maitre actor waits for the messages: prepare, consult, addFood, clear, stop, end. When it receives the message:
<ul>
    <li>prepare: sends the prepare message to the rbr specifing the food and the crockery;</li>
    <li>addFood: sends the addFood message to the rbr specifing the food;</li>
    <li>clear: sends the consult message to the table to get the items to remove; sends the clear message to the rbr specifing the food and the crockery;</li>
    <li>consult: sends the consult message to all resources and waits for their answers;</li>
    <li>stop: sends the stop message to the rbr when this is received it waits just for the reactivate message;</li>
    <li>reactivate: sends the reactivate message to the rbr;</li>
    <li>end: sends the end message to the rbr and terminate.</li>
</ul>

<h3>MaitreGui</h3>
The software it's realized as a web app using the Spring framework.<br>
The package it.unibo.connQak implements functions to send message to the actors with different protocols(in TCP, MQTT, CoAP, HTTP); the connQakBase works as a factory class for classes to sends messages to the actors using the TCP, HTTP, CoAP, MQTT protocols.<br>
The maitreResource  sends the commands to the maitre actor by TCP and receives the answers observing by CoAP the actor; in an hexagonal architecture this class is the use case. <br>
The controller works as a Spring controller and intercepts the Get request to execute the right behaviuor using maitreResource and showing the right HTML page.<br>
Immagine view => controller => maitreResource (use cases) <br>

<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Models</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text" rowspan="3">
		<br><a href="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/Controller.kt" target="_blank">Controller.kt</a><br><br>
		<iframe class="qakSprint2max" src="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/Controller.kt" title="Controller from maitreGUI project">Controller from maitreGUI project</iframe>
		<br><br><hr><br>
		<a href="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/MaitreResource.kt" target="_blank">MaitreResource.kt</a><br><br>
		<iframe class="qakSprint2max" src="../../maitreGUI/src/main/kotlin/it/unibo/maitreGUI/MaitreResource.kt" title="MaitreResource from maitreGUI project">MaitreResource from maitreGUI project</iframe>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/CommunicationGuiMaitre.svg" alt="Communications between GUI (maitreGUI project) and maitre actor">
	</td>
</tr>
<tr class="text">
	<th>Moore State Machine Diagrams/htlm pages images??</th>
</tr>
<tr>
	<td class="imageSchema">
		<img src="../../../ProblemAnalysisModel/userDocs/utils/img/ReqAnalysis/QActorFSMLegend.png" alt="Legend of the representations of the behaviors of the QActors, modeled as a Moore state machines"><br>
		<img src="./utils/img/FSM_RBRMapperQActor.svg" alt="Representation of the behavior of QActor rbrmapper, modeled as a Moore state machine"><br>
		<img src="./utils/img/FSM_RBRQActor.svg" alt="Representation of the behavior of QActor rbr, modeled as a Moore state machine">
	</td>
</tr>
</table>

<h2>Testing</h2>

The tests for this sprint ...

non sono stati fatti in quanto il maitre/il funzionamento del sistema era già stato testato negli sprint precedenti; mentre per quanto riguarda la parte di GUI, questa può essere testata provando a inviare comandi al maitre tramite la web application.

<h2><a name="Sprint3Mod"></a>Model of System's Logical Architecture</h2>

<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		Sprint 3 <a href="../src/model.qak" target="_blank">model.qak</a><br>
		<pre><iframe class="qakSprint" src="../src/model.qak" title="ModelSprint_3">Model of Sprint 3</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="./utils/img/ModelSprint3_Legend.svg" alt="Legend of the Logical Architecture System Model from Sprint 3"><br>
		<img src="./utils/img/ModelSprint_3.svg" alt="Logical Architecture System Model from Sprint 3">
	</td>
</tr>
</table>

<h2>Deployment</h2>



<h2>SCRUM Context</h2>

<h3>SPRINT Sequence</h3>

After this Sprint and according to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#ProdBack" target="_blank">Product Backlog</a>, listed after the problem analysis, a possibile set of next Sprint could be:
<dl>
	<dt>SPRINT 4</dt>
	<dd><ol>
		<li>Deploy on <tt>Raspberry</tt></li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Add Food</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Clear the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li>Tests</li>
	</ol></dd>
</dl>

<div hidden="hidden">
<h2>Maintenance</h2>
</div>

</div>
<br><br>
<div class="endpage">
By Romeo Stefano (stefano.romeo@studio.unibo.it) and Russo Maria (maria.russo10@studio.unibo.it)<br>
<img class="photo" src="../../../userDocs/utils/img/StefanoRomeo.png" alt="Stefano Romeo image">
<img class="photo" src="../../../userDocs/utils/img/MariaRusso.png" alt="Maria Russo image">
</div>

<div hidden="hidden">elementi utili:
Table:
<table>
<tr>
	<td></td>
	<td></td>
</tr>
</table>
Sorted List:
<ol>
<li></li>
<li></li>
</ol>
Unordered List:
<ul>
<li></li>
<li></li>
</ul>
Definition list:
<dl>
<dt></dt>
<dd></dd>
</dl>
Link:
<a href="" target="_blank"></a>
Link in pagina:
<a name="link"></a> + <a href="./SPRINT_2.html#link">text</a>
IFrame:
<iframe src="./src" title="title">"Link"/Cosa c'è nel frame</iframe>
<br>Image:
<img src="./utils/img/Nome.png" alt="description">
</div>

</body>
</html>
