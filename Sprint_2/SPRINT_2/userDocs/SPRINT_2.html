<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<link rel="stylesheet" type="text/css" href="./utils/style.css">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<base href=".">
<title>RomeoRussoStandingBuffetService</title>
</head>

<body>

<div id="top">
<h1>SPRINT 2 - STANDING BUFFET SERVICE | Ingegneria dei Sistemi Software</h1>
</div>

<div class="body">

<h2>Introduction</h2>

The starting point for this SPRINT is the resulting model from the <a href="../../../Sprint_1/SPRINT_1/userDocs/SPRINT_1.html#Sprint1Mod" target="_blank">previous Sprint 1</a>:
<br><br>
<table>
<tr class="text">
	<th>Machine Understandable Architecture Model</th>
	<th>A Possible Graphic Representation</th>
</tr>
<tr>
	<td class="text">
		SPRINT_1 <a href="../../../Sprint_1/SPRINT_1/src/model.qak" target="_blank">model.qak</a><br>
		<pre><iframe class="qakSprint" src="../../../Sprint_1/SPRINT_1/src/model.qak" title="Sprint_1_Model">Model of Sprint 1</iframe></pre>
	</td>
	<td class="imageSchema">
		<img src="../../../Sprint_1/SPRINT_1/userDocs/utils/img/ModelSprint1_Legend.png" alt="Legend of the Logical Architecture System Model from Sprint 1"><br>
		<img src="../../../Sprint_1/SPRINT_1/userDocs/utils/img/ModelSprint_1.png" alt="Logical Architecture System Model from Sprint 1">
	</td>
</tr>
</table>

<h2>Goal</h2>

<div class="remark">
<ol>
	<li>Mapping: use of <k>basicrobot</k> and <tt>sonar</tt> to map the <ks>room</ks></li>
	<li><i><em>Avoid</em> the impact with obstacles</i> requirement</li>
	<li><em>Stop</em>/<em>Reactivate</em> feature</li>
	<li><ks>Prepare the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> <em>avoiding</em> the obstacles and receiving <em>stop</em> and then <em>reactivate</em> commands</li>
	<li><ks>Add Food</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> <em>avoiding</em> the obstacles and receiving <em>stop</em> and then <em>reactivate</em> commands</li>
	<li><ks>Clear the room</ks> <ks>task</ks>: path execution by the <tt>virtual robot</tt> <em>avoiding</em> the obstacles and receiving <em>stop</em> and then <em>reactivate</em> commands</li>
</ol>
</div>

<h2>Problem Analysis</h2>

The problems related to this sprint goals, that are already addressed in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#ProblemAn" target="_blank">initial problem analysis</a>, are detailed below.

<h3><a name="S2mapping"></a>Mapping</h3>

As already said in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnRBR" target="_blank">initial problem analysis</a>, to be able to map the <ks>room</ks>, it's possible to use data collected from a <tt>sensor</tt>, which can be represented by a <tt>sonar</tt> (in both virtual and real robot; in this Sprint, it will be a <tt>virtual robot</tt> (<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html" target="_blank">VirtualRobot2021.html</a>) running on its own <tt>WEnv</tt> (Web Environment) to solve the goals about the execution of the <ks>tasks</ks>). In the library <m>it.unibo.qak21.basicrobot-1.0.jar</m>, provided by the customer, the <tt>sonar</tt> is already integrated and used by the <k>basicrobot</k>.
<br><br>
Therefore, the mapping goal is to create a new <ks>room</ks> map, which in this sprint will be the virtual <ks>room</ks> in the <tt>WEnv</tt>, and to make possible this, it's necessary to communicate with the <k>basicrobot</k>, which, as already detailed in the <a href="../../../Sprint_1/SPRINT_1/userDocs/SPRINT_1.html#S1basicRobot" target="_blank">Sprint 1 problem analysis</a>, replies with a <em>stepfail</em> message in case it should find some obstacles (fixed, mobile or wall; in mapping case it will be sufficient to consider only fixed obstacles and walls).<br>
Furthermore, at each step carried out by the robot it's necessary also to update the <ks>room</ks> logical map and to do that it's useful the <tt>Planner</tt> support available in the library <m>it.unibo.planner20-1.0.jar</m> and discussed in the <a href="../../../Sprint_1/SPRINT_1/userDocs/SPRINT_1.html#S1planning" target="_blank">Sprint 1 problem analysis</a>.
<br><br>
<img src="../../../Sprint_1/SPRINT_1/userDocs/utils/img/basicRobotInRBRctx.png" alt="basicRobot in RBR context">

<h3><i>Avoid the Impact with Obstacles</i> Requirement</h3>

By <a href="../../../ProblemAnalysisModel/userDocs/utils/tf/TemaFinaleBo19.html" target="_blank">requirements</a>, the <ks>RBR</ks> must be able to <i><em>avoid</em> the impact with obstacles</i>; in particular, with mobile obstacles because walls and fixed obstacles (the <ks>table</ks>) are included in the <ks>room</ks> map, which in this sprint is produced by the <a href="./SPRINT_2.html#S2mapping">mapping</a>.<br>

As already said <a href="./SPRINT_2.html#S2mapping">above</a> and in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnRBR" target="_blank">initial problem analysis</a>, to satisfy the requirement <i><em>avoid</em> the impact with obstacles</i>, it's possible to use data collected from a <tt>sensor</tt>, which can be represented by a <tt>sonar</tt> (in both virtual and real robot; in this Sprint, it will be a <tt>virtual robot</tt> (<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html" target="_blank">VirtualRobot2021.html</a>) running on its own <tt>WEnv</tt> (Web Environment) to solve the goals about the execution of the <ks>tasks</ks>). In the library <m>it.unibo.qak21.basicrobot-1.0.jar</m>, provided by the customer, the <tt>sonar</tt> is already integrated and used by the <k>basicrobot</k>.
<br><br>
Indeed, as already detailed in the <a href="../../../Sprint_1/SPRINT_1/userDocs/SPRINT_1.html#S1basicRobot" target="_blank">Sprint 1 problem analysis</a>, when the <k>basicrobot</k> meets an obstacle (fixed, mobile or wall) sends a <em>stepfail</em> message describing the cause of the failure and after how long it occured.
<br><br>
Therefore, to address this problem, it could be sufficient to manage the <em>stepfail</em> message received from the <k>basicrobot</k> and, to do this, there can be different ways:
<ol>
	<li>temporarily setting the obstacle in the logical map and planning a new path to reach the goal; so to get around the obstacle. Then, before starting the execution of the next steps, the obstacle must be deleted from the logical map;</li>
	<li>waiting for the mobile obstacle to move and so periodically carrying out the movement until the cell that must be occupied will be free.</li>
</ol>

SCRIVERE CHE LA SCELTA VIENE FATTA IN FASE DI PROGETTAZIONE?

<h3><em>Stop</em>/<em>Reactivate</em> Feature</h3>

By <a href="../../../ProblemAnalysisModel/userDocs/utils/tf/TemaFinaleBo19.html" target="_blank">requirements</a>, the <ks>Maître de Salle</ks> can use the <em>stop</em> or <em>reactivate</em> command to stop or restart an already activated <ks>task</ks>, otherwise these commands have no effect.
<br>
In Sprint 1 it has been added a new <tt>actor</tt> (<k>rbrwalker</k> <ko>LINK</ko>) to manage the planning and communicating with the <k>basicrobot</k> <tt>actor</tt> to make the robot perform the movements, whether it is virtual or real; in this case virtual.
<br>
Therefore, referring to the result of the Sprint 1 and to hypothesis/solution at this problem advanced in the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnRBR" target="_blank">initial problem analysis</a>, to manage the the stop/reactivate commands received by the maitre, during the execution of a task, a possible solution can be to use the rbrwalker actor which, splitting the path the robot must execute in a steps sequence, at the end of each step it can check if it has received a stop command and in this case it must wait for the reactivate command, otherwise it can carry out the next step.
<br><br>
The communications for sending these commands could be implemented in different ways:
<ol>
  <li>The maitre could send the stop and reactivate commands to the rbr, which takes care of sending these commands to the rbrwalker;</li>
  <li>The maitre could send directly to the rbrwalker the stop and reactivate commands as dispatch;</li>
  <li>The maitre could send directly to the rbrwalker the stop command as a request, waiting for a failure or success reply, and the reactivate command as a dispatch;</li>
  <li>The maitre could send the stop command as an event that can be received by all the interessed actors, that, for now, it's just the rbrwalker.</li>
</ol>
From these solutions, the better choose, in this step/sprint, looks to be the <ko>LINK</ko> third one, because it's the rbrwalker that is interessed to receive these commands since it takes care of communicating with the basicrobot to move the robot. In future, if the system complexity will evolve and there will be more actors interessed to these commands, it would be necessary to implement the <ko>LINK</ko> fourth solution.

<ko>immagini per ogni soluzione?</ko>

<h2>Test Plans</h2>

With reference to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#PrAnTestPlans" target="_blank">initial problem analysis test plans</a>, below it's reported a functional tests planning related to the goals of this sprint:
<br><br>
<ul>
	<li>Tests of the state of the <ks>RBR</ks> to verify that it is stopped after receiving <em>stop</em> command and to verify that it resumes <ks>task</ks> execution after receiving the <em>reactivate</em> command;</li>
	<li>Tests of the <em>stop</em> and <em>reactivate</em> commands that can be used by <ks>Maître de salle</ks> only when there is a running <ks>task</ks>;</li>
	<li>Test of the capability of the <ks>RBR</ks> to <em>avoid</em> all the possible obstacles.</li>
</ul>

<h2>Project</h2>

<h3>Mapping</h3>

In Sprint 1, for the planning it has been created a project <ko>LINK</ko> MapBinGenerator which creats a room logical map taking in input the dimension of the map to create and the coordinates of the obstacles.<br>
Instead, in this sprint, it has been introduced the mapping feature that provides a logical map of any type of room, either it is real or virtual, by exploiting the basicrobot to map it, without having to know the map dimensions or the obstacles positions.<br>
To realize this behavior it seemed to be more appropriate to create a new <tt>actor</tt> (<k>rbrmapper</k>) in <k>rbr</k> <tt>context</tt> (<k>ctxrbr</k>) which, after receiving the request (map) from the rbr actor, takes care of the room mapping and communicating with the basicrobot actor to make the robot perform the movements, whether it is virtual or real (in this case virtual), and to detect when the robot meets a wall or a fixed obstacle (the table in this case). To create the new map it uses also the Planner support.
<br><br>
In particular, after receiving a map request from the rbr actor, the rbrmapper communicates with the basicrobot to move the robot making him explore the perimeter of the room:
<ol>
	<li>sending to the basicrobot a request message step for forward movements until it receives the reply stepfail when the robot has met a wall; otherwise it updates the logical map using Planner command updateMap every time it receives the reply stepdone;</li>
	<li>sending to the basicrobot, once received stepfail reply, a dispatch message cmd(l) to turn left the robot.</li>
</ol>
The rbrmapper repeats this sequence of actions until it comes back to the RH position.<br>
Then, this actor starts to explore the internal spaces of the room:
<ol>
	<li>using the Planner command planForNextDirty, which returns a list of actions to reach the first unexplored cell in the logical map;</li>
	<li>sending a request message step for forward movement, by waiting for the reply stepdone or stepfail respectively in case of success or fail when the robot meets an obstacle (the table), and a dispatch message cmd for the other movements;</li>
	<li>updating at each step the logical map using Planner command updateMap, when it receives the stepdone reply or when it sends the dispatch cmd, or the Planner command updateMapObstacleOnCurrentDirection when it receives the stepfail reply.</li>
</ol>
The rbrmapper repeats this sequence of actions until it has explored every cell in the logical map.<br>
After this, this actor sends a request message setGoal(0, 0, downDir) to the rbrwalker actor to make the robot to come back to the RH position with the correct direction.<br>
Afterwards, when the rbrmapper receives the reply goalState from the rbrwalker, it saves the created map through the Planner command saveRoomMap and replies to the rbr actor with the message mapdone.<br>
Finally, it terminates itself.
<br><br>
It was introduced also the possibility for the rbr to know if the room logical map it's already present by consulting a prolog file <ko>LINK</ko> IsMap.pl and in this case the rbr actor sends a dispatch end to the rbrmapper which terminate itself.

<ko>LINK attore + image qak attore + immagine comunicazione tra attori + immagine rbr qak mapping + immagine a stati del mapper</ko>

<h3><i><em>Avoid</em> the impact with obstacles</i> requirement</h3>

<br><br>
//TODO: gestire l'ostacolo nel caso in cui occupi il goal:
				//Sol 1. fare in modo che il robot aspetti che si sposti l'ostacolo
				//Sol 2. se il goal è la home allora sol 1; se il goal è una risorsa allora si cerca l altro goal più vicino?
			//Si sceglie sol 1

WENV OSTACOLI

<h3><em>Stop</em>/<em>Reactivate</em> feature</h3>

Furthermore, it must be manage the possibility to receive the command before the execution of a task and in this case the stop request must be ignored.

<h3></h3>



<h2>Testing</h2>

Below there are exposed some tests made for this sprint project:

<dl>
	<dt><a href="../test/it/unibo/test/StopAndReactivateTest.kt" target="_blank">StopAndReactivateTest.kt</a></dt>
	<dd>Tests about the correct execution of the stop/reactivate feature:<ol>
		<li><em>StopAndReactivateTest</em>: it's tested that the stop command fail when the rbrwalker it's in a wait state and that has success when it's in moving step than it's tested that the reactivate command works.
		
		after the send of a <em>prepare</em> command to the <k>rbr</k>, which runs the <ks>Prepare the room</ks> <ks>task</ks>, it's verified that, for each sub-path the robot must execute, the final position of the robot is the expected one and that the reached resource state has been changed. In particular, this test:<ol>
			<li>Sends a <em>prepare</em> message to <k>rbr</k> <tt>actor</tt>;</li>
			<li>Checks that the robot position, taken from the <k>rbrwalker</k> state, is the expected cell in front of <ks>pantry</ks>;</li>
			<li>Checks that the crockery removed from the <k>pantry</k> are the expected;</li>
			<li>Checks that the robot position, taken from the <k>rbrwalker</k> state, is the <ks>RH</ks> position.</li>
		</ol></li>
	</ol></dd>
</dl>

Tests of the state of the <ks>RBR</ks> to verify that it is stopped after receiving <em>stop</em> command and to verify that it resumes <ks>task</ks> execution after receiving the <em>reactivate</em> command.

Test about the stop message:
 StopAndReactivateTest: it's tested that the stop command fail when the rbrwalker it's in a wait state and that has success when it's in moving step than it's tested that the reactivate command works.
 1. Sends a stop request to rbrwalker actor;
 2. Checks that stop request fails;
 3. Sends a setGaol message
 4. Sends a stop request to rbrwalker actor;
 5. Checks that stop request works;
 6. Sends a reactivate message;
 7.  Checks that reactivate request works;
 8. Checks that the final robot position, taken from the rbrwalker state, is the expected one;
 
 <dl>
	<dt><a href="../test/it/unibo/test/AvoidMobileObstacleTest.kt" target="_blank"> AvoidMobileObstacleTest.kt</a></dt>
	<dd>Tests about the correct execution of the  feature avoid mobile obstacle:<ol>
	<li>AvoidMobileObstacleTest: it's tested that  rbrwalker calculates a new path when meets an obstacle. For this test it's need the presence of an obstacle in the map, placed in the expected path walked by the robot.</li>
		<li> Sends a setGaol message;</li>
		<li> Cheks that an obstacle is met:</li>
		<li> Checks that the final robot position, taken from the rbrwalker state, is the expected one.</li>
		</ol></li>
	</ol></dd>
</dl>

<h2>Model of System's Logical Architecture</h2>



<h2>Deployment</h2>



<h2>SCRUM Context</h2>

<h3>SPRINT Sequence</h3>

After this Sprint and according to the <a href="../../../ProblemAnalysisModel/userDocs/Analysis.html#ProdBack" target="_blank">Product Backlog</a>, listed after the problem analysis, a possibile set of next Sprint could be:
<dl>
	<dt>SPRINT 3</dt>
	<dd><ol>
		<li><tt>GUI</tt> <ks>maître's smartphone</ks> software</li>
		<li>Tests</li>
	</ol></dd>
	<br>
	<dt>SPRINT 4</dt>
	<dd><ol>
		<li>Deploy on <tt>Raspberry</tt></li>
		<li><ks>Prepare the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Add Food</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li><ks>Clear the room</ks> <ks>task</ks>: execution by the <tt>real robot</tt></li>
		<li>Tests</li>
	</ol></dd>
</dl>

<h2>Maintenance</h2>

</div>
<br><br>
<div class="endpage">
By Romeo Stefano (stefano.romeo@studio.unibo.it) and Russo Maria (maria.russo10@studio.unibo.it)<br>
<img class="photo" src="../../../userDocs/utils/img/StefanoRomeo.png" alt="Stefano Romeo image">
<img class="photo" src="../../../userDocs/utils/img/MariaRusso.png" alt="Maria Russo image">
</div>

<div hidden="hidden">elementi utili:
Table:
<table>
<tr>
	<td></td>
	<td></td>
</tr>
</table>
Sorted List:
<ol>
<li></li>
<li></li>
</ol>
Unordered List:
<ul>
<li></li>
<li></li>
</ul>
Definition list:
<dl>
<dt></dt>
<dd></dd>
</dl>
Link:
<a href="" target="_blank"></a>
Link in pagina:
<a name="link"></a> + <a href="./SPRINT_2.html#link">text</a>
IFrame:
<iframe src="./src" title="title">"Link"/Cosa c'è nel frame</iframe>
<br>Image:
<img src="./utils/img/Nome.png" alt="description">
</div>

</body>
</html>
